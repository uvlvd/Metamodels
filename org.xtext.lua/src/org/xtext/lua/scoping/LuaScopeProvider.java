/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.scoping;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.linking.impl.LinkingHelper;
import org.eclipse.xtext.linking.lazy.SyntheticLinkingSupport;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.lua.lua.Assignment;
import org.xtext.lua.lua.Block;
import org.xtext.lua.lua.Exp;
import org.xtext.lua.lua.ExpList;
import org.xtext.lua.lua.Feature;
import org.xtext.lua.lua.LuaPackage.Literals;
import org.xtext.lua.lua.MemberAccess;
import org.xtext.lua.lua.Referenceable;
import org.xtext.lua.lua.Referencing;
import org.xtext.lua.lua.Stat;
import org.xtext.lua.lua.TableAccess;
import org.xtext.lua.lua.Var;
import org.xtext.lua.utils.LinkingAndScopingUtils;

import com.google.inject.Inject;
import com.google.inject.Scope;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class LuaScopeProvider extends AbstractLuaScopeProvider {
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	
  	@Inject
    private IQualifiedNameConverter nameConverter;
  	
	@Inject 
	private LinkingHelper linkingHelper;
	
	@Inject
	private SyntheticLinkingSupport linkingSupport;
    
    @Override
    public IScope getScope(final EObject context, final EReference reference) {
        if (context == null) {
            // nothing todo without context
            return IScope.NULLSCOPE;
        }
        
        // TODO: write doc for the method instead of the below comment
        // handle scope for assignables, i.e. set their reference to the value they are assigned to
        if (LinkingAndScopingUtils.isAssignable(context)) {
        	return getScopeForAssignable(context);
        }
        
        if (context instanceof TableAccess tableAccess && tableAccess.getName().equals("testName")) {
    		System.out.println("TableAccess with null as name found");
    		System.out.println("	before:" + tableAccess);
    		var exp = (Var) tableAccess.getIndexExp();
    		
    		System.out.println("	Index expression: " + exp);
    		var temp = exp.getRef();
    		//tableAccess.setName("dummyName");
    		System.out.println("	Ref of index expression: " + exp.getRef());
    		System.out.println("	Assigned Value of index expression: " + ((Referencing) exp.getRef()).getRef());
    		tableAccess.setRef(((Referencing) exp.getRef()).getRef());
    		
    		var name = LinkingAndScopingUtils.tryResolveExpressionToString(exp);
    		System.out.println("	New TableAccess Name: " + name);
    		//set name attribute
    		tableAccess.setName(name);
    		//set cross-reference linkText 
    		linkingSupport.createAndSetProxy(tableAccess, Literals.REFERENCING__REF, name);
    		System.out.println("	after:" + tableAccess);
    		var scope = getScope(tableAccess, Literals.REFERENCING__REF);
    		System.out.println(scope);
    		return scope;
    	}
    	

        if (context instanceof Referencing referencing) {
        //if (context instanceof Referencing referencing && ((context instanceof Var) || (context instanceof MemberAccess))) {
        	final var contextFqn = qualifiedNameProvider.getFullyQualifiedName(context);

        	//TODO: it seems that the lazy linking happens before the DerivedStateComputer
        	// 	installs the derived state, thus the name is null.
        	//  need to change that somewhere...
        	if (contextFqn == null) {
        		return IScope.NULLSCOPE;
        	}
        	
        	// TODO: get parent/blockscope instead of accessing the rootElement
        	var rootElement = EcoreUtil2.getRootContainer(referencing);
        	var assignments = EcoreUtil2.getAllContentsOfType(rootElement, Assignment.class);
        	
        	
        	
        	
        	List<Referenceable> candidates = assignments.stream()
        								 //.map(Assignment::eContents)
        								 .map(assignment ->  EcoreUtil2.getAllContentsOfType(assignment, Referenceable.class))
        								 .flatMap(List::stream)
        								 //.filter(obj -> !(obj instanceof ExpList && (obj instanceof Referenceable))) // filter non-lhs objects
        								 .filter(obj -> LinkingAndScopingUtils.isAssignable(obj))
        						//		 .flatMap(obj -> {
        									 //var refbles = EcoreUtil2.getAllContentsOfType(obj, Referenceable.class);
        					//				 var refbles = EcoreUtil2.getAllContentsOfType(obj, Referenceable.class);
        					//				 if (obj instanceof Var var)
        					//					 refbles.add(var);
        					//				 System.out.println("foo " + refbles);
        					//				 return refbles.stream();
        					//			 })
        								 // TODO: remove, just needed as long as not all refbles are implemented
        								 //.filter(refble -> (refble instanceof Var) || (refble instanceof MemberAccess))
        								 //.map(refble -> (Referenceable) refble)
        								 //.filter(refble -> contextFqn.equals(qualifiedNameProvider.getFullyQualifiedName(refble)))
        								 .filter(refble -> {
        									 //TODO: if context is feature inside Tableaccess the refble fqn is not equal
        									 if (contextFqn.toString().equals("a.testName.str") || 
        											 contextFqn.toString().equals("a.dummyName.str") ||
        											 contextFqn.toString().equals("a.member.str")) {
        							        	return nameConverter.toQualifiedName("str").equals(qualifiedNameProvider.getFullyQualifiedName(refble));
        									 }
        									 return contextFqn.equals(qualifiedNameProvider.getFullyQualifiedName(refble));
        								 })
        								 .toList();
        	

        	//System.out.println("name: " + contextFqn);
        	//System.out.println("candidates for " + referencing + ": " + candidates);
        	/*
        	var descriptions = candidates.stream()
   				 .map(candidate -> {
   					 var fqn = qualifiedNameProvider.getFullyQualifiedName(candidate); // TODO: throw error here if null, explaining that the LuaQualifiedNameProvider needs to be updated for all EObjects
   			    	 System.out.println("desc: " + fqn);
   					 return EObjectDescription.create(fqn, candidate);
   				 })
   				 .toList();
        	return new SimpleScope(IScope.NULLSCOPE, descriptions);
        	*/
        	//System.out.println("candidates for obj '" + contextFqn + "': " + candidates);
        	//Collections.reverse(candidates);
        	
        	if (context instanceof Var var && var.getName().equals("str")) {
        		System.out.println("var: " + var + ", candidates: " + candidates);
        		if (candidates.isEmpty()) {
        			System.out.println(contextFqn);
        		} else {
        			var v = (Var) candidates.get(0);
        			System.out.println("Assigned value: " + v.getRef());
        		}
        	}
        	
        	/*
        	if (context instanceof TableAccess tableAccess && tableAccess.getName().equals("testName")) {
        		System.out.println("TableAccess with null as name found");
        		var exp = (Var) tableAccess.getIndexExp();
        		System.out.println("	Index expression: " + exp);
        		var temp = exp.getRef();
        		tableAccess.setName("dummyName");
        		System.out.println("	Ref of index expression: " + exp.getRef());
        		System.out.println("	Assigned Value of index expression: " + ((Referencing) exp.getRef()).getRef());
        		tableAccess.setRef(((Referencing) exp.getRef()).getRef());
        	}
*/
        	
        	return Scopes.scopeFor(candidates);
        	
    	//System.out.println("Getting scope for Var...");
    		//return getScopeForVar(var, reference);
        }
        // TODO: the getScopeFor...() functions need to get a parentScope passed or they will match anything in the model
   //     if (context instanceof Var var) {
        	//System.out.println("Getting scope for Var...");
      //  	return getScopeForVar(var, reference);
    //    }
        
     //   if (context instanceof MemberAccess memberAccess) {
        	//System.out.println("Getting scope for var MemberAccess...");
     //   	return getScopeForMemberAccess(memberAccess, reference);
      //  }        

        var parentBlock = EcoreUtil2.getContainerOfType(context.eContainer(), Block.class);
        if (parentBlock == null) {
            // if we have no parent anymore we delegate to the global scope
        	//System.out.println("TODO: Implement global scope");
        	//System.out.println(context);
        	return super.getScope(context, reference); // TODO: just for debug, remove
            //return super.getGlobalScope(context.eResource(), reference);
        }
        
        //System.out.println("current context: " + context);
        //System.out.println("context parent: " + context.eContainer());
        var parentStatement = EcoreUtil2.getContainerOfType(context, Stat.class);
        //var blockScope = getScopeOfBlock(parentBlock, context, parentStatement, reference);
        //return blockScope;
        return IScope.NULLSCOPE;
        
        
        /*
        var scope = super.getScope(context, reference);
        var temp = new ArrayList<IEObjectDescription>();
        scope.getAllElements().forEach(temp::add);
        if (temp.isEmpty()) {
        	System.out.println("Scope empty for obj: " + context);
        }
        return super.getScope(context, reference); // TODO: just for debug, remove
        */
    }
    
    private IScope getScopeForAssignable(EObject assignable) {
    	final var value = LinkingAndScopingUtils.findAssignedExp((Feature) assignable);
		if (value == null) {
			// TODO: create transient "nil" eObject?
			// reference self when no assigned value is part of the ExpList (rhs of Assignment)
			return Scopes.scopeFor(Collections.singletonList(assignable));
		} else {
			// any assignable is also a Referenceable which has a name attribute and a
			// cross-reference with linkText == name
			var name = ((Referenceable) assignable).getName();
			var fqn = nameConverter.toQualifiedName(name);
			var assignedValueDescription = EObjectDescription.create(fqn, value);
			return new SimpleScope(Collections.singletonList(assignedValueDescription));
		}
    }
   
    
}
