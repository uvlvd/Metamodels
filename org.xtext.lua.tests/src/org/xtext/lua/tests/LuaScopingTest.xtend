/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.lua.lua.Chunk
import org.eclipse.emf.ecore.EObject
import java.io.ByteArrayOutputStream
import org.xtext.lua.PreprocessingUtils
import org.eclipse.xtext.resource.DerivedStateAwareResource

@ExtendWith(InjectionExtension)
@InjectWith(LuaInjectorProvider)
class LuaScopingTest {
	@Inject
	ParseHelper<Chunk> parseHelper
	
	
	def static String dump(EObject mod_, String indent) {
	    var res = indent + mod_.toString.replaceFirst ('.*[.]impl[.](.*)Impl[^(]*', '$1 ')
	
	    for (a :mod_.eCrossReferences) 
	        res += ' ->' + a.toString().replaceFirst ('.*[.]impl[.](.*)Impl[^(]*', '$1 ')
	    res += "\n"
	    for (f :mod_.eContents) {
	        res += f.dump (indent+"    ")
	    }
	    return res
	}
	
	def void check(Chunk chunk, String original, Boolean expectedToFail) {
		if (!expectedToFail) {
			check(chunk, original)
			return
		}
		
		Assertions.assertNotNull(chunk)
		val errors = chunk.eResource.errors
		Assertions.assertFalse(errors.isEmpty)
	}	

	def void check(Chunk chunk, String original) {
		Assertions.assertNotNull(chunk)
		val errors = chunk.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
		checkEquality(chunk, original)
	}
	
	def void checkEquality(Chunk chunk, String original) {
		val outputStream = new ByteArrayOutputStream()
		chunk.eResource.save(outputStream, #{})
		val parsedAndPrinted = outputStream.toString()
		
		val origExtremelyCanonical = removeComments(original)
		val parsedAndPrintedExtremelyCanonical = removeComments(parsedAndPrinted)

		val equivalence = origExtremelyCanonical.equals(parsedAndPrintedExtremelyCanonical)
		if (!equivalence) {
			System.out.println("===== Original: =====")
			System.out.println(original)
			System.out.println("===== Parsed and serialized: =====")
			System.out.println(parsedAndPrinted)
			
			System.out.println("===== Original canonical (extremely so): =====")
			System.out.println(origExtremelyCanonical)
			System.out.println("===== Parsed and serialized canonical: =====")
			System.out.println(parsedAndPrintedExtremelyCanonical)
		}
		Assertions.assertTrue(equivalence)
	}
	
	// TODO: rename, it replaces all whitespace also
	def String removeComments(String string) {
		val withoutComments = PreprocessingUtils.removeComments(string)
		return PreprocessingUtils.removeAllWhiteSpacesAndNewLines(withoutComments)	 
	}
	
	
	
	
	
	@Test
	def void scopingTest() { 
		val SUT = '''
			a = 1
			b = a
			
			--for num = 1, 10 do
			--	a = a + num
			--end
			
			--for i, j in {1,2,3}, {4,5,6} do
			--	b = i+j
			--end
			--test.member[1].func()[2].field = 1
			--var = 1
			--a = var
			--a.b, a = 2, 3
			--a = 10
			--b = a
			--test.member[1] = t.member[1]
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingMemberTest() { 
		val SUT = '''
			l = {}
		    l.member, k, j = 10, 11, 12
			a = {}
			a.member = {}
			a.member.secondMember = 10
			b = a
			c = a.member
			d = a.member.secondMember
			x, y = l.member, a.member
			
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingTableAccessTest() { 
		val SUT = '''
			a = {}
		    a["member"] = 1
		    b = a["member"]
		    c = a.member
		    str = "member" --TODO
		    d = a[str]
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
}
