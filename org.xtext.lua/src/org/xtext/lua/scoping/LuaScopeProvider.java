/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.scoping;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.SimpleLocalScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.lua.linking.SyntheticExpNil;
import org.xtext.lua.lua.Block;
import org.xtext.lua.lua.Exp;
import org.xtext.lua.lua.ExpField;
import org.xtext.lua.lua.Field;
import org.xtext.lua.lua.FunctionDeclaration;
import org.xtext.lua.lua.Goto;
import org.xtext.lua.lua.IndexExpField;
import org.xtext.lua.lua.Label;
import org.xtext.lua.lua.NameField;
import org.xtext.lua.lua.Referenceable;
import org.xtext.lua.lua.Referencing;
import org.xtext.lua.lua.TableConstructor;
import org.xtext.lua.utils.LinkingAndScopingUtils;

import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class LuaScopeProvider extends SimpleLocalScopeProvider {
	private static final Logger LOGGER = Logger.getLogger(LuaScopeProvider.class);
	
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	
  	@Inject
    private IQualifiedNameConverter nameConverter;
    
	/**
	 * NOTE: Always create IEObjectDescriptions using the qualifiedNameConverter when creating
	 * Scopes, see {@link #createDescriptionsForCandidates(Collection)}.
	 */
    @Override
    public IScope getScope(final EObject context, final EReference reference) {
        if (context == null) {
            // nothing to do without context
            return IScope.NULLSCOPE;
        }
        
        var scope = getScopeForAssignableToValue(context);
        if (scope != null) {
        	return scope;
        }
        
        System.out.println(context + ": " + qualifiedNameProvider.getFullyQualifiedName(context));
        scope = getScopeByTraversingBlocks(context);
        
        if (scope != null) {
        	return scope;
        }
        
		// search global scope if no candidates were found in local scope
    	//TODO: implement global scope
		return super.getGlobalScope(context.eResource(), reference);
		//return IScope.NULLSCOPE;
    }
    

    /**
     * Assignables and Fields reference their assigned value, this returns the respective scope.</br>
     * E.g.: a = {b = 1} returns 1 for context object b, and the right-hand side TableConstructor for context object a.
     * @param context the context object.
     * @return the scope, or null if the context object is not an assignable or Field.
     */
    private IScope getScopeForAssignableToValue(EObject context) {
        // fields (in TableConstructors) also reference their assigned value
        if (context instanceof Field field) {
        	return getScopeForField(field);
        }
    	// assignables (variables that get assigned a value in an Assignment) reference their assigned value
        if (LinkingAndScopingUtils.isAssignable(context)) {
        	return getScopeForAssignable(context);
        }
        
        return null;
    }

    /**
     * Returns the Scope for assignables. Assignables are Referenceables on the lhs of an Assignment,
     * and the returned Scope contains a single candidate: the corresponding value expression on the rhs of the Assignment. </br>
     * If there is no corresponding value expression (e.g. a, b = 1), a new ExpNil is created and set as reference (in the e.g. b).
     * @param assignable
     * @return
     */
    private IScope getScopeForAssignable(EObject assignable) {
    	final var name = ((Referenceable) assignable).getName();
		if (name == null) { // name might be null, e.g. for TableAccess with unresolvable indexExpression
			// TODO: return placeholder object or implement trivial recovery
			// TODO: name should not be null anymore, since TableAccesses get a dummy name?
			return IScope.NULLSCOPE;
		}
		
    	final var fqn = nameConverter.toQualifiedName(name);
    	final var value = LinkingAndScopingUtils.findAssignedExp(assignable);
		if (value == null) {
			// create synthetic nil value if ExpList does not contains value for assignable
			var nilValue = new SyntheticExpNil();
			var nilValueDescription = EObjectDescription.create(fqn, nilValue);
			return new SimpleScope(Collections.singletonList(nilValueDescription));
		} else {
			// any assignable is also a Referenceable which has a name attribute and a
			// cross-reference with linkText == name

			// we create a description with the name of the assignable and the corresponding value expression on the rhs of the assignment
			// => the scope for the assignable contains only this description
			var assignedValueDescription = EObjectDescription.create(fqn, value);
			return new SimpleScope(Collections.singletonList(assignedValueDescription));
		}
    }
    
    
    //TODO: this does not seem like the right location for this method, since the field names are computed here
    //      but the tableAccess names are computed in LuaLinkingService...
    /**
     * Returns the Scope for Fields. Every field has a value, which is the candidate returned in the returned scope.
     * Since not all names for fields can be computed, some fields may get assigned a dummy name.
     */
    private IScope getScopeForField(Field field) {
    	Exp value = null;
    	if (field instanceof IndexExpField indexExpField) {
    		value = indexExpField.getValueExp();
    	} else if (field instanceof NameField nameField) {
    		value = nameField.getValueExp();
    	} else if (field instanceof ExpField expField) {
    		value = expField.getExp();
    	}
    	
    	if (value == null) {
    		throw new RuntimeException("Could not determine value expression for field " + field);
    	}
    	
    	var name = field.getName();
    	if (name.equals(LinkingAndScopingUtils.DERIVED_DUMMY_NAME)) {
    		name = LinkingAndScopingUtils.tryGetNameForField(field, LinkingAndScopingUtils.LINKING_DUMMY_NAME);
    	}
    	
    	var fqn = nameConverter.toQualifiedName(name);
    	var assignedValueDescription = EObjectDescription.create(fqn, value);
    	return new SimpleScope(Collections.singletonList(assignedValueDescription));
    }

    
    private IScope getScopeByTraversingBlocks(final EObject context) {
    	final var currentBlock = EcoreUtil2.getContainerOfType(context, Block.class);
    	return getScopeByTraversingBlocks(context, currentBlock, null);
    }
    
    private IScope getScopeByTraversingBlocks(final EObject context, final Block currentBlock, final Block previousBlock) {
    	// search for candidates in current block
    	var candidates = getCandidatesFromBlock(context, currentBlock, previousBlock);
    	if (!candidates.isEmpty()) {
    		return new SimpleScope(createDescriptionsForCandidates(candidates, context));
    	}
    	
    	// search for candidates in parent block if none were found in current block
    	final var parentBlock = EcoreUtil2.getContainerOfType(currentBlock.eContainer(), Block.class);
		if (parentBlock != null) {
			return getScopeByTraversingBlocks(context, parentBlock, currentBlock);
		}
		
		// no parent block found, try global scope
		return null;
    }
    
    private List<? extends Referenceable> getCandidatesFromBlock(final EObject context, final Block currentBlock, final Block previousBlock) {
    	List<? extends Referenceable> candidates = new ArrayList<>();
    	// Get candidate Labels for Goto: Label names need to be unique within one block)
    	if (context instanceof Goto) {
    		// TODO: do not search global scope for GOTO references
    		candidates = getReferenceablesForGoto(currentBlock, previousBlock);
    	}
    	 // handle other Referencing objects
        if (context instanceof Referencing referencing) {
        	final var contextFqn = qualifiedNameProvider.getFullyQualifiedName(context);

        	//TODO: it seems that the lazy linking happens before the DerivedStateComputer
        	// 	installs the derived state, thus the name is null.
        	//  need to change that somewhere...?
        	if (contextFqn != null) {
        		// TODO: getReferenceables should be renamed
	        	var referenceables = getReferenceables(context, currentBlock);
	        	candidates = findCandidatesInReferenceablesforFqn(contextFqn, referenceables);
        	}
        }
        return candidates;
    }
    
    // For functions, this could be a problem here: https://stackoverflow.com/questions/12291203/lua-how-to-call-a-function-prior-to-it-being-defined
    //  (could also affect Assignments)
    private List<? extends Referenceable> getReferenceables(final EObject context, final Block contextBlock) {
    	if (qualifiedNameProvider.getFullyQualifiedName(context).toString().equals("m.[first]")) {
			System.out.println("> breakpoint");
		}
    	var referenceables = LinkingAndScopingUtils.getReferenceablesForContextFromBlock(context, contextBlock);
    	// reverse result s.t. the last assignment before the currently considered context is the first element in the resulting candidate list
    	Collections.reverse(referenceables);
    	return referenceables;
    }
    
    
    private List<? extends Referenceable> getReferenceablesForGoto(final Block contextBlock, final Block previousBlock) {
    	var referenceables = EcoreUtil2.getAllContentsOfType(contextBlock, Label.class)
    			.stream()
    			// we ignore the previous block, since it has been searched before (see getScopeByTraversingBlocks)
    			.filter(block -> block != previousBlock)
    			.collect(Collectors.toCollection(() -> new ArrayList<>()));
    	Collections.reverse(referenceables);
    	return referenceables;
    }
    
	// function findCandidatesInPathForFqn(fqn) that searches for feature candidates by fqn:
	// 1. Add all candidates with contextFqn.equals(candidateFqn) to result
    // 2.1 find all candidates with contextFqn.startsWith(candidateFqn)
	// 2.2 filter by: candidate.pointsToTable() 
	// 3. forall candidates if pointsToTable: 
    //    3.1 newFqnHead = candidate.getRef().getFqn()  // quit here if cannot be resolved
	//    3.2 contextFqnTail = contextFqn.remove(candidateFqn)
	//    3.3 furtherCandidates = findCandidatesInPathByFqn(newFqnHead + contextFqnTail)
	// 	  3.4 add result as description with (candidate.getFqn() + contextFqnTail, furtherCandidate)
	// 4. return candidates
    /**
     * 
     * @param contextFqn
     * @param context
     * @param scopeRoot
     * @return
     */
    //private Collection<Referenceable> findCandidatesInPathForFqn(QualifiedName contextFqn, final EObject context, final EObject scopeRoot) {
    //	var assignables = getAssignablesFromFor(scopeRoot, context);
    private List<? extends Referenceable> findCandidatesInReferenceablesforFqn(final QualifiedName contextFqn, final Collection<? extends Referenceable> referenceables) {
    	var result = new ArrayList<Referenceable>();

    	for (final var referenceable : referenceables) {
    		
    		if (contextFqn.toString().equals("m.[first]")) {
    			System.out.println("	refbles: " + referenceables);
    		}
    		
    		final var referenceableFqn = qualifiedNameProvider.getFullyQualifiedName(referenceable);
    		if (contextFqn.equals(referenceableFqn)) { // add all assignables with equal fqn
    			result.add(referenceable);
    		} else if (contextFqn.startsWith(referenceableFqn)) {
    			// TODO: check this out
    			if (!(referenceable instanceof Referencing)) {
    				// TODO: this will be logged e.g. when a function return value is accessed, e.g. see scopingFunctionDeclarationTest a.x.memberFunc()["member"]
    				LOGGER.warn("Skipped resolution of sub-part of feature path for non-referencing \n		" 
    							+ referenceable + " with fqn " 
    						    + referenceableFqn + 
    						    " for contextFqn " + contextFqn);
    				continue;
    			}
    			// search candidates in partial feature paths, 
    			// e.g.: b.member = 1; a.x = b; c = a.x.member; here, the candidates for a.x.member need to consider b.member
        		final var assignedRef = (((Referencing) referenceable).getRef()); // rhs of assignable (might be a Referencing)
    			final var assignedValue = LinkingAndScopingUtils.tryGetAssignedValueFrom((Referencing) referenceable); // value of assignable (is not Referencing)
	
        		if (assignedValue instanceof TableConstructor && assignedRef instanceof Referencing) {
        			var newFqnHead = qualifiedNameProvider.getFullyQualifiedName(assignedRef);
        			var newFqnTail = getFqnTail(contextFqn, referenceableFqn.getSegmentCount());
        			var newFqn = newFqnHead.append(newFqnTail);
        			
        			result.addAll(findCandidatesInReferenceablesforFqn(newFqn, referenceables)
        				.stream()
        				.toList()
        			);
        			
        		}
        		
    		}
    	}

    	return result;
    }
    
    private QualifiedName getFqnTail(QualifiedName forFqn, int startIndex) {
    	var resultSegments = new ArrayList<String>();
    	for (var i = 0; i < forFqn.getSegmentCount(); i++) {
    		if (i >= startIndex) {
    			resultSegments.add(forFqn.getSegment(i));
    		}
    	}
    	
    	if (resultSegments.isEmpty()) {
    		throw new RuntimeException("Cannot get tail for " + forFqn + " with startIndex " + startIndex + "!");
    	}
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (int i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    /**
     * We always need to create descriptions (instead of returning Scopes.scopeFor(candidates)), since the 
     * candidates name might contain ".", which would fail to match the QualifiedName generated from the cross-reference
     * in the DefaultLinkingService.</br>
     * This is because the qualifiedNameConverter uses "." to separate Strings, i.e.
     * the generated cross-reference QualifiedName for "hello.world" would be "hello" "world", which would not match
     * the candidate's name "hello.world".</br></br>
     * 
     * An alternative would be to extend the IQualifiedNameConverter.DefaultImpl and change/remove the delimiter.</br></br>
	 *
     * @param candidates The candidates.
     * @return A list of EObjectDescriptions of the candidates, created by applying the qualifiedNameConverter to the candidate's name attribute.
     */
    private Collection<IEObjectDescription> createDescriptionsForCandidates(Collection<? extends Referenceable> candidates, EObject context) {
    	return candidates.stream()
    				.map(c ->{
    					var name = c.getName();
    					if (c instanceof FunctionDeclaration fd) {
    						name = getLastSegmentFromFunctionDeclarationName(fd);
    					}
    					return EObjectDescription.create(nameConverter.toQualifiedName(name), c);
    				})
    				.toList();
    }

    private String getLastSegmentFromFunctionDeclarationName(FunctionDeclaration fd) {
    	var qn = nameConverter.toQualifiedName(fd.getName());
    	return qn.getLastSegment();
    } 
    
}
