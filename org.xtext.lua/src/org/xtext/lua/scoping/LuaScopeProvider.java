/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.scoping;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import org.apache.log4j.Logger;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.ImportUriResolver;
import org.eclipse.xtext.scoping.impl.SimpleLocalScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.lua.linking.SyntheticExpNil;
import org.xtext.lua.lua.Block;
import org.xtext.lua.lua.Exp;
import org.xtext.lua.lua.ExpField;
import org.xtext.lua.lua.Feature;
import org.xtext.lua.lua.Field;
import org.xtext.lua.lua.FuncBody;
import org.xtext.lua.lua.FunctionCall;
import org.xtext.lua.lua.FunctionDeclaration;
import org.xtext.lua.lua.Goto;
import org.xtext.lua.lua.IndexExpField;
import org.xtext.lua.lua.Label;
import org.xtext.lua.lua.MemberAccess;
import org.xtext.lua.lua.NameField;
import org.xtext.lua.lua.Referenceable;
import org.xtext.lua.lua.Referencing;
import org.xtext.lua.lua.Return;
import org.xtext.lua.lua.TableAccess;
import org.xtext.lua.lua.TableConstructor;
import org.xtext.lua.lua.Var;
import org.xtext.lua.utils.LinkingAndScopingUtils;

import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class LuaScopeProvider extends SimpleLocalScopeProvider {
	private static final Logger LOGGER = Logger.getLogger(LuaScopeProvider.class);
	
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	
  	@Inject
    private IQualifiedNameConverter nameConverter;
    
	
	@Inject
	ImportUriResolver uriResolver;
	
	/**
	 * NOTE: Always create IEObjectDescriptions using the qualifiedNameConverter when creating
	 * Scopes, see {@link #createDescriptionsForCandidates(Collection)}.
	 */
    @Override
    public IScope getScope(final EObject context, final EReference reference) {
        if (context == null) {
            // nothing to do without context
            return IScope.NULLSCOPE;
        }
        
        var scope = getScopeForAssignableToValue(context);
        
        if (scope != null) {
        	return scope;
        }

        //TODO: 
        // when an assignemnt like test = require("core.lua").member is at the top of a file,
        // the "member" cannot be resolved because the Statement is ignored when building candidates for traversing blocks
        // or something... need to get candidates from the require call and search for member in them (maybe using
        // getCandidatesForFeature)???
        
        // we pass context and reference for calls to "require" (need to call the global scope, see getReferenceablesFromRequireCall)
        scope = getScopeByTraversingBlocks(context, reference);
        
        if (scope != null) {
        	return scope;
        }
        
		// search global scope if no candidates were found in local scope
        // For assignments where an assignable is assigned to a require-call, the global scope is resolved when searching referenceable candidates for features
        System.out.println("Searchign global scope for " + context);
		return super.getGlobalScope(context.eResource(), reference);
    }
    
    /**
     * Returns the referenceable objects from the return expression at the given index of a call to the "require" function.
     * @param context
     * @param reference
     * @param index
     * @param requireFuncCall
     * @return
     */
    private List<Referenceable> getReferenceablesFromRequireCall(final EObject context, EReference reference, int index, Var requireFuncCall) {
    	final var uri = URI.createURI(uriResolver.apply(requireFuncCall));
    	var globalScope2 = super.getGlobalScope(context.eResource(), 
    											reference, 
    											LuaGlobalScopeProvider.returnedExpAtIndexFilter(0, uri.toString())
    											);
    	
    	return StreamSupport.stream(globalScope2.getAllElements().spliterator(), false)
    				.map(obj -> obj.getEObjectOrProxy())
    				.filter(obj -> obj instanceof Referenceable)
    				.map(obj -> (Referenceable) obj)
    				.toList();
    }
    

    /**
     * Assignables and Fields reference their assigned value, this returns the respective scope.</br>
     * E.g.: a = {b = 1} returns 1 for context object b, and the right-hand side TableConstructor for context object a.
     * @param context the context object.
     * @return the scope, or null if the context object is not an assignable or Field.
     */
    private IScope getScopeForAssignableToValue(EObject context) {
        // fields (in TableConstructors) also reference their assigned value
        if (context instanceof Field field) {
        	return getScopeForField(field);
        }
    	// assignables (variables that get assigned a value in an Assignment) reference their assigned value
        if (LinkingAndScopingUtils.isAssignable(context)) {
        	return getScopeForAssignable(context);
        }
        
        return null;
    }

    /**
     * Returns the Scope for assignables. Assignables are Referenceables on the lhs of an Assignment,
     * and the returned Scope contains a single candidate: the corresponding value expression on the rhs of the Assignment. </br>
     * If there is no corresponding value expression (e.g. a, b = 1), a new ExpNil is created and set as reference (in the e.g. b). </br>
     * @param assignable
     * @return
     */
    private IScope getScopeForAssignable(EObject assignable) {
    	final var name = ((Referenceable) assignable).getName();
		if (name == null) { // name might be null, e.g. for TableAccess with unresolvable indexExpression
			// TODO: return placeholder object or implement trivial recovery
			// TODO: name should not be null anymore, since TableAccesses get a dummy name?
			return IScope.NULLSCOPE;
		}
		
    	final var fqn = nameConverter.toQualifiedName(name);
    	final var value = LinkingAndScopingUtils.findAssignedExp(assignable);
		if (value == null) {
			// create synthetic nil value if ExpList does not contains value for assignable
			var nilValue = new SyntheticExpNil();
			var nilValueDescription = EObjectDescription.create(fqn, nilValue);
			return new SimpleScope(Collections.singletonList(nilValueDescription));
		} else {
			// any assignable is also a Referenceable which has a name attribute and a
			// cross-reference with linkText == name

			// we create a description with the name of the assignable and the corresponding value expression on the rhs of the assignment
			// => the scope for the assignable contains only this description
			var assignedValueDescription = EObjectDescription.create(fqn, value);
			return new SimpleScope(Collections.singletonList(assignedValueDescription));
		}
    }
    
    
    //TODO: this does not seem like the right location for this method, since the field names are computed here
    //      but the tableAccess names are computed in LuaLinkingService...
    /**
     * Returns the Scope for Fields. Every field has a value, which is the candidate returned in the returned scope.
     * Since not all names for fields can be computed, some fields may get assigned a dummy name.
     */
    private IScope getScopeForField(Field field) {
    	Exp value = null;
    	if (field instanceof IndexExpField indexExpField) {
    		value = indexExpField.getValueExp();
    	} else if (field instanceof NameField nameField) {
    		value = nameField.getValueExp();
    	} else if (field instanceof ExpField expField) {
    		value = expField.getExp();
    	}
    	
    	if (value == null) {
    		throw new RuntimeException("Could not determine value expression for field " + field);
    	}
    	
    	var name = field.getName();
    	if (name.equals(LinkingAndScopingUtils.DERIVED_DUMMY_NAME)) {
    		name = LinkingAndScopingUtils.tryGetNameForField(field, LinkingAndScopingUtils.LINKING_DUMMY_NAME);
    	}
    	
    	var fqn = nameConverter.toQualifiedName(name);
    	var assignedValueDescription = EObjectDescription.create(fqn, value);
    	return new SimpleScope(Collections.singletonList(assignedValueDescription));
    }

    
    private IScope getScopeByTraversingBlocks(final EObject context, final EReference reference) {
    	final var currentBlock = EcoreUtil2.getContainerOfType(context, Block.class);
    	return getScopeByTraversingBlocks(context, reference, currentBlock, null);
    }
    
    private IScope getScopeByTraversingBlocks(final EObject context, final EReference reference, final Block currentBlock, final Block previousBlock) {
    	// search for candidates in current block
    	var candidates = getCandidatesFromBlock(context, reference, currentBlock, previousBlock);
    	if (!candidates.isEmpty()) {
    		return new SimpleScope(createDescriptionsForCandidates(candidates, context));
    	}
    	
    	// search for candidates in parent block if none were found in current block
    	final var parentBlock = EcoreUtil2.getContainerOfType(currentBlock.eContainer(), Block.class);
		if (parentBlock != null) {
			return getScopeByTraversingBlocks(context, reference, parentBlock, currentBlock);
		}
		
		// no parent block found, try global scope
		return null;
    }
    
    private List<? extends Referenceable> getCandidatesFromBlock(final EObject context, final EReference reference, final Block currentBlock, final Block previousBlock) {
    	// Get candidate Labels for Goto: Label names need to be unique within one block)
    	if (context instanceof Goto) {
    		// TODO: do not search global scope for GOTO references
    		return getReferenceablesForGoto(currentBlock, previousBlock);
    	}
    	
    	if (context instanceof Feature feature) {
    		var referenceables = getReferenceables(context, currentBlock);
    		return getCandidatesForFeature(feature, reference, referenceables);
    	}
    	
    	throw new RuntimeException("Expected to be able to compute candidates from context object " + context + ", but its type " + context.getClass() + " is not supported.");
    	
    	/*
    	// handle other Referencing objects
        if (context instanceof Referencing referencing) {
        	final var contextFqn = qualifiedNameProvider.getFullyQualifiedName(context);

        	
        	//TODO: it seems that the lazy linking happens before the DerivedStateComputer
        	// 	installs the derived state, thus the name is null.
        	//  need to change that somewhere...?
        	if (contextFqn != null) {
        		// TODO: getReferenceables should be renamed
	        	var referenceables = getReferenceables(context, currentBlock);
	        	
	        	if (context instanceof Feature feature) {
	        		temp = getCandidatesForFeature(feature, referenceables);
	        	} else {
	        		System.out.println("!!! Not searching candidates with new function for " + context);
	        	}
	        	
	        	candidates = findCandidatesInReferenceablesforFqn(contextFqn, referenceables);
	        	
	        	if (!candidates.equals(temp)) {
		            System.out.println("Candidates for context " + context + " with fqn " + contextFqn);
		            System.out.println("	previous candidates: " + candidates);
		            System.out.println("	temp candidates    : " + temp);
	        	}
        	}
        }

        return temp;
        */
    }
    
    // For functions, this could be a problem here: https://stackoverflow.com/questions/12291203/lua-how-to-call-a-function-prior-to-it-being-defined
    //  (could also affect Assignments)
    private List<? extends Referenceable> getReferenceables(final EObject context, final Block contextBlock) {
    	// we use the parentStatement to decide where to stop searching for candidates (i.e. only consider statements before the context's statement)
		final var contextParentStatementOpt = LinkingAndScopingUtils.getParentStatement(context);
    	if (!contextParentStatementOpt.isPresent()) {
    		LOGGER.warn("Found no contextParentStatement for obj " + context);
    		return Collections.emptyList();
    	}
    	final var contextParentStatement = contextParentStatementOpt.get();
    	
    	var referenceables = LinkingAndScopingUtils.getReferenceablesForContextFromBlock(context, contextBlock, contextParentStatement);

    	return referenceables;
    }
    
    private List<? extends Referenceable> getReferenceablesForGoto(final Block contextBlock, final Block previousBlock) {
    	var referenceables = EcoreUtil2.getAllContentsOfType(contextBlock, Label.class)
    			.stream()
    			// we ignore the previous block, since it has been searched before (see getScopeByTraversingBlocks)
    			.filter(block -> block != previousBlock)
    			.collect(Collectors.toCollection(() -> new ArrayList<>()));
    	Collections.reverse(referenceables);
    	return referenceables;
    }
    
    /**
     * Searches for candidates for the given Feature by traversing its feature path, starting from the root featur and matching
     * each feature path segment to the respective segment of the fully qualified name of the candidate. 
     * @param feature the feature.
     * @param referenceables the referenceables to be searched.
     * @return
     */
    // TODO: rename getCandidatesForFeature and/or findCandidatesForFeature
    private List<? extends Referenceable> getCandidatesForFeature(Feature feature, final EReference reference, final Collection<? extends Referenceable> referenceables) {
    	
    	final var featurePathCandidates = findCandidatesThatMatchUntil(feature, reference, referenceables);
    	return featurePathCandidates.stream()
				 .filter(FeaturePathCandidate::isCompletelyMatched)
				 .map(FeaturePathCandidate::getReferenceable)
				 .toList();
    }
    
    /**
     * Returns all FeaturePathCandidates that match the given feature's featurePath until the feature itself, i.e.
     * the returned candidates contain candidates with a path that continues after the match of the given feature.</br>
     * The returned candidates can be filtered via {@link FeaturePathCandidate#isCompletelyMatched} to get the matching candidates for the given feature
     * (see {@link #getCandidatesForFeature}).
     * @param feature
     * @param referenceables
     * @return
     */
    private List<FeaturePathCandidate> findCandidatesThatMatchUntil(final Feature feature, final EReference reference, final Collection<? extends Referenceable> referenceables) {
    	//TODO: checkout LinkingAndScopingUtils.findFeaturePathRoot, which only returns roots for Referenceables
    	//    -> should probably be renamed

    	// we use features here to be able to distinguish between function/methodCalls and other feature types
    	final var featurePathRoot = LinkingAndScopingUtils.getFeaturePathRoot(feature);
    	final var featurePathCandidates = buildFeaturePathCandidates(referenceables);
   
    	// get initial candidates for path root
    	var candidates = findCandidatesForFeature(feature, reference, featurePathRoot, featurePathCandidates);
    	// iterate over all path elements until the feature we started from
    	Feature previousFeature = featurePathRoot;
    	while (previousFeature != feature) {
    		var currentFeature = LinkingAndScopingUtils.getNextFeature(previousFeature);
    		candidates = findCandidatesForFeature(feature, reference, currentFeature, candidates);
    		previousFeature = currentFeature;

    	}
    	return candidates;
    }
    

    // this returns all candidates that can be reached by traversing a feature path, using the current and previous features
    // it is important to note, that this will return all candidates based on if the feature path matches UNTIL the current location
    // in the feature paths. That is, candidates that match and have a next feature component will be returned regardless of if a next feature exitst for the context feature
    // TODO: update doc
    /**
     * Searches for candidates inside the given candidates and referenceables based on the current and previous elements of a feature path.</br>
     * The intended use is to find scoping candidates for a (start of a) feature path. For this, call this function first with current = featurePathRoot and previous = null,
     * then subsequently call it with the corresponding next current and previous features of the feature path, and finally with the last previous element and current = null. </br>
     * To get initial candidates, call with previous = null. Call with current = null when reaching the end of the considered feature path.</br>
     * If used to get candidates from a feature path without a subsequent call with current = null, the returned candidates may contain
     * candidates that match until the last current, but have further elements. 
     * 
     * @param current the current feature in the path.
     * @param previous the next feature in the path.
     * @param candidates the candidates from a previous call of this method. Candidates correspond to allReferenceables on initial call.
     * @param allReferenceables all referenceables that should be considered for the search.
     * @return
     */
    private List<FeaturePathCandidate> findCandidatesForFeature(
    		final EObject context,
    		final EReference reference,
    		final Feature current, 
    		final Collection<FeaturePathCandidate> candidates) {
    
    	var result = new ArrayList<FeaturePathCandidate>();

    	// handle current is function/methodCall feature
    	if (LinkingAndScopingUtils.isFunctionCallFeature(current)) {
    		// We have two possibilities here: 1. previous is named feature or 2. previous itself was functionCallFeature:
    		// In both cases the remaining candidates should already contain only viable candidates from a previous call of this function.
    		for (var candidate : candidates) {
    			if (candidate.isCompletelyMatched()) { // candidate can only be functionCallCandidate if it is completely matched
    				final var candidateContext = candidate.getReferenceable();
    				final var candidateFuncBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(candidateContext);
    				result.addAll(getFeaturePathCandidatesFromFuncBody(candidateFuncBody));		
    			}
    		}
    		return result;
    	}
    	
    	// handle current is named feature (i.e. Var, MemberAccess or TableAccess)
    	// => from here, we assume that current is a Referenceable (since named features are referenceables)
    	assert(current instanceof Referenceable); // TODO: throw exception instead
    	final var currentFqn = qualifiedNameProvider.getFullyQualifiedName(current);
    	final var currentName = currentFqn.getLastSegment();
    	// check for all candidates if they match, build new candidates from function calls and candidates that reference other Referenceables
    	for (var candidate : candidates) {
    		if (candidate.checkAndIncrementIndex(currentName)) {
    			result.add(candidate); // candidate matches, keep as part of result
    				
    			// find new candidates from references and add them to the result
    			if (candidate.referencesReferencing()) {	
    				// this is the rhs expression the candidate points at if it is an assignable:
    				// -> points at the start of a featurePath if it is a feature
    				var assignedReferencing = candidate.getReferencedReferencing(); // TODO: is this always a feature if this is referencing?
    				result.addAll(buildCandidatesFromAssignedReferencing(context, reference, assignedReferencing));		
    			}
    		}
    	}

    	return result;
    }
    
    // assignedReferencing is a Referencing Feature on the rhs (first element of a feature path) that was assigned to an assignable
    private List<FeaturePathCandidate> buildCandidatesFromAssignedReferencing(final EObject context, final EReference reference, final Referencing assignedReferencing) {
    	if (assignedReferencing instanceof Feature feature) {
    		var leaf = LinkingAndScopingUtils.getFeaturePathNamedLeaf(feature);
			var referencedByLeaf = ((Referencing) leaf).getRef();
    		
    		// handle require calls here, since they/what they reference are/is defined by the first part of the featurePath
			// TODO
			if (assignedReferencing instanceof Referenceable ref && ref.getName().equals("require")) {// TODO: use static string for "require", already used in LuaImportUriResolver
				if (LinkingAndScopingUtils.hasNextFeature(feature)) {
					var next = LinkingAndScopingUtils.getNextFeature(feature);
					if (next instanceof FunctionCall funcCall) {
						var temp = getReferenceablesFromRequireCall(context, reference, 0, (Var) feature);
						System.out.println("temp: " + temp);
						var indexToCheck = qualifiedNameProvider.getFullyQualifiedName(feature).getSegmentCount();
						// TODO: need to filter the candidates from the getReferenceablesFromRequireCall by the rest of the
						// FeaturPath until leaf? Test first what happens when require is resolved for assignment,
						return buildFeaturePathCandidates(getReferenceablesFromRequireCall(context, reference, 0, (Var) feature), indexToCheck); // TODO: use dynamic indexToCheck
					}
				}
			}
			
			// handle other kinds of feature calls here: 
			// 1. get named leaf, 
			// 2. get referenced Referenceable, 
			// 3. get possible Referenceables, 
			// 4. get candidates by calling findCandidatesThatMatchUntil(Referenceable, Referenceables)

			// get candidates from function calls
			if (LinkingAndScopingUtils.isFunctionDeclaration(referencedByLeaf)) {
				final var candidateFuncBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(referencedByLeaf);
				return getFeaturePathCandidatesFromFuncBody(candidateFuncBody);
			}
			// get candidates from referenced feature paths
			else if (referencedByLeaf instanceof Feature referencedFeature) {
				var referencedBlock = EcoreUtil2.getContainerOfType(referencedFeature, Block.class);
				var referenceablesInReferencedBlock = LinkingAndScopingUtils.getReferenceablesForContextFromBlock(referencedFeature, referencedBlock, null);
				return findCandidatesThatMatchUntil(referencedFeature, reference, referenceablesInReferencedBlock);
			} 
			// there should be no other options then function calls and feature paths
			else {
				throw new RuntimeException("Unexpected type: " + referencedByLeaf + ", exprected function declaration or Feature.");
			}
		} else {
			throw new RuntimeException("Expected Feature type, but got " + assignedReferencing + ".");
		}
    }
    
    
    private List<FeaturePathCandidate> getFeaturePathCandidatesFromFuncBody(FuncBody funcBody) {
    	if (funcBody == null) {
    		return Collections.emptyList();
    	}
    
		final var containingBlock = funcBody.getFuncBlock();
		List<FeaturePathCandidate> result = new ArrayList<>();
		
		final var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(containingBlock);
		if (returnStatOpt.isPresent()) {
			var returnStat = returnStatOpt.get();
		
			final var exps = LinkingAndScopingUtils.getExpsFromReturnStat(returnStat);
			if (!exps.isEmpty()) {
				final var exp = exps.get(0);
				if (exp instanceof Feature feature) {
					final var leaf = LinkingAndScopingUtils.getFeaturePathNamedLeaf(feature);
					final var expFqn = qualifiedNameProvider.getFullyQualifiedName(leaf);
					final var indexToMatch = expFqn.getSegmentCount();
					LinkingAndScopingUtils.getReferenceablesForContextFromBlock(returnStat, containingBlock, null)
						.stream()
						.filter(referenceable -> qualifiedNameProvider.getFullyQualifiedName(referenceable).startsWith(expFqn))
						.map(ref -> buildFeaturePathCandidate(ref, indexToMatch))
						.forEach(result::add);
				}
			}
		}

		return result;
    }
    
    /**
     * Returns the FeaturePathCandidates found in the given features scope. The FeaturePathCandidate.indexToMatch
     * is set to the features qualifiedName segmentCount.
     * @param feature
     * @return
     */
    /*
    private List<FeaturePathCandidate> getFeaturePathCandidatesFromScopeForFeature(Feature feature) {
		final IScope leafScope = getScope(feature, null);
		if (leafScope != null) {
			final var indexToCheckForCandidate = qualifiedNameProvider.getFullyQualifiedName(feature).getSegmentCount();
			final var newCandidates = StreamSupport.stream(leafScope.getAllElements().spliterator(), false)
					.map(description -> description.getEObjectOrProxy())
					.filter(obj -> obj instanceof Referenceable)
					.map(obj -> (Referenceable) obj)
					.toList();
			System.out.println("new candidates: " + newCandidates);
			return buildFeaturePathCandidates(newCandidates, indexToCheckForCandidate);
		}
		return Collections.emptyList();
    }
    */
    private List<FeaturePathCandidate> buildFeaturePathCandidates(final Collection<? extends Referenceable> referenceables) {
    	return buildFeaturePathCandidates(referenceables, 0);
    }
    
    private List<FeaturePathCandidate> buildFeaturePathCandidates(final Collection<? extends Referenceable> referenceables, final int startIndex) {
    	return referenceables.stream()
    						 .map(referenceable -> buildFeaturePathCandidate(referenceable, startIndex))
    						 .toList();
    }
    
    private FeaturePathCandidate buildFeaturePathCandidate(final Referenceable referenceable) {
    	return buildFeaturePathCandidate(referenceable, 0);
    }
    
    private FeaturePathCandidate buildFeaturePathCandidate(final Referenceable referenceable, final int startIndex) {
    	final var fqn = qualifiedNameProvider.getFullyQualifiedName(referenceable);
    	return new FeaturePathCandidate(referenceable, fqn, startIndex);
    }
    
    
    
    private int getFeaturePathCountUntilLastFunctionCallFeature(Feature feature) {
    	if (feature == null || LinkingAndScopingUtils.isFunctionCallFeature(feature)) {
    		return 0;
    	}

    	int length = 1; // we start at the given feature, i.e. path has at least one element
    	// we use the fqn to ensure that the length returned here does not exceed the feature's fqn, e.g. when it stops at TableAccesses
    	var fqn = qualifiedNameProvider.getFullyQualifiedName((Referenceable) feature);
    	var parent = feature.eContainer();
    	while (parent instanceof Feature f && length < fqn.getSegmentCount()) {
    		// only count features with a name (i.e. Var, MemberAcces, TableAccess)
    		if (!LinkingAndScopingUtils.isFunctionCallFeature(f)) {
    			length++;
    		}
    		parent = parent.eContainer();
    	}
    	
    	return length;
    }
    
    private List<? extends Referenceable> findReferenceablesForFunctionReference(Referenceable functionReference) {
    	var result = new ArrayList<Referenceable>();
    	if (functionReference instanceof Referencing referencing) {
    		// TODO: might need to get referenced function if the given functionReference is a Referencing object (e.g. func = func1, b = func())
    		//    could use LinkingAndScopingUtils.tryGetAssignedValueFrom(referencing) or smth similar
    	}
    	if (LinkingAndScopingUtils.isFunctionDeclaration(functionReference)) {
			System.out.println("fooooooUnctionDeclaration");
			var funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(functionReference);
			if (funcBody != null) {
				var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(funcBody.getFuncBlock());
				if (returnStatOpt.isPresent()) {
					var referenceablesFromCandidate = LinkingAndScopingUtils.getReferenceablesFromReturnStat(returnStatOpt.get(), qualifiedNameProvider);
					// only add candidates from first returned expression
					if (!referenceablesFromCandidate.isEmpty()) {
						result.addAll(referenceablesFromCandidate.get(0));
					}
					
				}
			}
		}
    	return result;
    }
    
    private List<? extends Referenceable> findCandidatesForFunctionCalls(final Collection<? extends Referenceable> candidates) {
    	var result = new ArrayList<Referenceable>();
    	
    	for (final var candidate : candidates) {
        	if (LinkingAndScopingUtils.isFunctionDeclaration(candidate)) {
    			System.out.println("fooooooUnctionDeclaration");
    			var funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(candidate);
    			if (funcBody != null) {
    				var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(funcBody.getFuncBlock());
    				if (returnStatOpt.isPresent()) {
    					var referenceablesFromCandidate = LinkingAndScopingUtils.getReferenceablesFromReturnStat(returnStatOpt.get(), qualifiedNameProvider);
    					// only add candidates from first returned expression
    					if (!referenceablesFromCandidate.isEmpty()) {
    						result.addAll(referenceablesFromCandidate.get(0));
    					}
    					
    				}
    			}
    		}
    	}
    	
    	return result;
    }
    

    
    private List<? extends Referenceable> temp(Feature current, Feature previous, final Collection<? extends Referenceable> candidates) {
    	var result = new ArrayList<Referenceable>();
    	
    	return result;
    }
    

    
    private QualifiedName getFqnTail(QualifiedName forFqn, int startIndex) {
    	var resultSegments = new ArrayList<String>();
    	for (var i = 0; i < forFqn.getSegmentCount(); i++) {
    		if (i >= startIndex) {
    			resultSegments.add(forFqn.getSegment(i));
    		}
    	}
    	
    	if (resultSegments.isEmpty()) {
    		throw new RuntimeException("Cannot get tail for " + forFqn + " with startIndex " + startIndex + "!");
    	}
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (int i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    private QualifiedName getFqnTailIncluding(QualifiedName forFqn, int startIndex) {
    	var resultSegments = new ArrayList<String>();
    	for (var i = 0; i < forFqn.getSegmentCount(); i++) {
    		if (i >= startIndex) {
    			resultSegments.add(forFqn.getSegment(i));
    		}
    	}
    	
    	if (resultSegments.isEmpty()) {
    		return null;
    		//throw new RuntimeException("Cannot get tail for " + forFqn + " with startIndex " + startIndex + "!");
    	}
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (int i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    
    /**
     * We always need to create descriptions (instead of returning Scopes.scopeFor(candidates)), since the 
     * candidates name might contain ".", which would fail to match the QualifiedName generated from the cross-reference
     * in the DefaultLinkingService.</br>
     * This is because the qualifiedNameConverter uses "." to separate Strings, i.e.
     * the generated cross-reference QualifiedName for "hello.world" would be "hello" "world", which would not match
     * the candidate's name "hello.world".</br></br>
     * 
     * An alternative would be to extend the IQualifiedNameConverter.DefaultImpl and change/remove the delimiter.</br></br>
	 *
     * @param candidates The candidates.
     * @return A list of EObjectDescriptions of the candidates, created by applying the qualifiedNameConverter to the candidate's name attribute.
     */
    private Collection<IEObjectDescription> createDescriptionsForCandidates(Collection<? extends Referenceable> candidates, EObject context) {
    	return candidates.stream()
    				.map(c ->{
    					var name = c.getName();
    					if (c instanceof FunctionDeclaration fd) {
    						name = getLastSegmentFromFunctionDeclarationName(fd);
    					}
    					return EObjectDescription.create(nameConverter.toQualifiedName(name), c);
    				})
    				.toList();
    }

    private String getLastSegmentFromFunctionDeclarationName(FunctionDeclaration fd) {
    	var qn = nameConverter.toQualifiedName(fd.getName());
    	return qn.getLastSegment();
    } 
    
}
