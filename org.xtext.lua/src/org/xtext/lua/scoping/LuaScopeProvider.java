/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.scoping;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.linking.impl.LinkingHelper;
import org.eclipse.xtext.linking.lazy.SyntheticLinkingSupport;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.lua.Config;
import org.xtext.lua.linking.SyntheticExpNil;
import org.xtext.lua.lua.Assignment;
import org.xtext.lua.lua.Block;
import org.xtext.lua.lua.Exp;
import org.xtext.lua.lua.ExpList;
import org.xtext.lua.lua.Feature;
import org.xtext.lua.lua.FunctionDeclaration;
import org.xtext.lua.lua.LuaFactory;
import org.xtext.lua.lua.LuaPackage.Literals;
import org.xtext.lua.lua.MemberAccess;
import org.xtext.lua.lua.Referenceable;
import org.xtext.lua.lua.Referencing;
import org.xtext.lua.lua.Stat;
import org.xtext.lua.lua.TableAccess;
import org.xtext.lua.lua.TableConstructor;
import org.xtext.lua.lua.Var;
import org.xtext.lua.utils.LinkingAndScopingUtils;

import com.google.inject.Inject;
import com.google.inject.Scope;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class LuaScopeProvider extends AbstractLuaScopeProvider {
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	
  	@Inject
    private IQualifiedNameConverter nameConverter;
  	
	@Inject 
	private LinkingHelper linkingHelper;
	
	@Inject
	private SyntheticLinkingSupport linkingSupport;
	
	@Inject
	private LuaFactory luaFactory = LuaFactory.eINSTANCE;
    
	
	/**
	 * NOTE: Always create IEObjectDescriptions using the qualifiedNameConverter when creating
	 * Scopes, see {@link #createDescriptionsForCandidates(Collection)}.
	 */
    @Override
    public IScope getScope(final EObject context, final EReference reference) {
        if (context == null) {
            // nothing todo without context
            return IScope.NULLSCOPE;
        }
        
        var scopeRoot = EcoreUtil2.getRootContainer(context);
        
        // TODO: do not assign rhs to variables that have been already declared (e.g. a[str] = 1: str should reference str declaration, not 1)
        if (LinkingAndScopingUtils.isAssignable(context)) {
        	return getScopeForAssignable(context);
        }
        
        
        //if (Config.TABLE_ACCESS_REFERENCES) {
        if (false) {
	        /**
	         * For now, this is just a proof-of-concept. With this (and setting a name and ref for TableAccess in the DerivedStateComputer), 
	         * TableAccess indexes could be resolved s.t. the TableAccess references a given table field.
	         */
	        if (LinkingAndScopingUtils.isTableAccessWithDummyName(context)) {
	        	System.out.println("foo");
	        	var ta = (TableAccess) context;
	        	var name = LinkingAndScopingUtils.tryResolveExpressionToString(ta.getIndexExp());
	        	
	        	
	        	var taDummyFqn = qualifiedNameProvider.getFullyQualifiedName(ta);
	        	var candidatesName = taDummyFqn.toString().replace(LinkingAndScopingUtils.DERIVED_DUMMY_NAME, name);
	        	var candidates = getCandidatesFromAssignablesFor(ta, nameConverter.toQualifiedName(candidatesName));
    			//if (name != null) {
    			//	ta.setName(name);
    			//	ta.setRef(ta.getRef());
    			//	
    			//}

	        	//var candidates = findCandidatesInPathForFqn(qualifiedNameProvider.getFullyQualifiedName(ta), scopeRoot);
	        	//var candidates = findCandidatesInPathForFqn(nameConverter.toQualifiedName(candidatesName), scopeRoot);
	        	// Set reference to indexExp if it could not be resolved
	        	if (candidates.isEmpty()) {
	        		//return new SimpleScope(Collections.singletonList(EObjectDescription.create(LinkingAndScopingUtils.DUMMY_NAME, ta.getIndexExp())));
	        	}

	        	return new SimpleScope(candidates.stream()
	        			.map(c -> EObjectDescription.create(LinkingAndScopingUtils.DERIVED_DUMMY_NAME, c))
	        			.toList());
	    	}
        }
    	

        if (context instanceof Referencing referencing) {
        	final var contextFqn = qualifiedNameProvider.getFullyQualifiedName(context);

        	//TODO: it seems that the lazy linking happens before the DerivedStateComputer
        	// 	installs the derived state, thus the name is null.
        	//  need to change that somewhere...?
        	if (contextFqn == null) {
        		return IScope.NULLSCOPE;
        	}
        	
        	
        	//List<Referenceable> candidates_old = getCandidatesFromAssignablesFor(referencing, contextFqn);	
        	
        	//var candClone = new ArrayList<>(candidates);
        	//Collections.reverse(candClone);
        	//System.out.println(candClone);
        	
        	//var funcCandidates = getCandidatesFromFunctionDefs();
        	/*
        	System.out.println("Searching for: " + contextFqn);
        	var rootElement = EcoreUtil2.getRootContainer(context);
        	var functionDeclarations = EcoreUtil2.getAllContentsOfType(rootElement, FunctionDeclaration.class);
        	var funcCandidates = functionDeclarations.stream()
    				 .map(funcDecl ->  funcDecl.getFuncName())
    				 //.flatMap(List::stream)
    				 //.filter(obj -> LinkingAndScopingUtils.isAssignable(obj))
    				 .filter(refble ->  {
    					 //var fullFuncName = refble.getRefs().isEmpty() ? refble.getName() : ; 
    					// var list = new ArrayList<String>();
    					// list.addAll(refble.getRefs().stream().map(ref -> ((Referenceable)ref.getRef()).getName()).toList());
    					// list.add(refble.getName());
    					// var qn = list.stream().map(null)
    					 
    					 System.out.println("	refble: " + refble);
    					 //var qn = qualifiedNameProvider.getFullyQualifiedName(refble);
    					 var qn = nameConverter.toQualifiedName(refble);
    					 System.out.println("   " + qn);
    					 return contextFqn.equals(qn);
    				 })
    				 .toList();
        	System.out.println(funcCandidates);
        	*/
      	
        	
        	var candidates = findCandidatesInPathForFqn(contextFqn, context, scopeRoot);
        	
        	if (referencing instanceof MemberAccess ma) {
        		return new SimpleScope(createDescriptionsForMemberAccess(candidates));
        	}
        	
        	
        	//return new SimpleScope(createDescriptionsForCandidates(candidates_old));
        	
        	return new SimpleScope(createDescriptionsForCandidates(candidates));
        }
    
        // TODO: parentBlocks, Functions etc.
        var parentBlock = EcoreUtil2.getContainerOfType(context.eContainer(), Block.class);
        if (parentBlock == null) {
            // if we have no parent anymore we delegate to the global scope
        	//System.out.println("TODO: Implement global scope");
        	//System.out.println(context);
        	return super.getScope(context, reference); // TODO: just for debug, remove
            //return super.getGlobalScope(context.eResource(), reference);
        }
        
        //System.out.println("current context: " + context);
        //System.out.println("context parent: " + context.eContainer());
        var parentStatement = EcoreUtil2.getContainerOfType(context, Stat.class);
        //var blockScope = getScopeOfBlock(parentBlock, context, parentStatement, reference);
        //return blockScope;
        return IScope.NULLSCOPE;
        
        
        /*
        var scope = super.getScope(context, reference);
        var temp = new ArrayList<IEObjectDescription>();
        scope.getAllElements().forEach(temp::add);
        if (temp.isEmpty()) {
        	System.out.println("Scope empty for obj: " + context);
        }
        return super.getScope(context, reference); // TODO: just for debug, remove
        */
    }

    /**
     * Returns the Scope for assignables. Assignables are Referenceables on the lhs of an Assignment,
     * and the returned Scope contains a single candidate: the corresponding value expression on the rhs of the Assignment. </br>
     * If there is no corresponding value expression (e.g. a, b = 1), a new ExpNil is created and set as reference (in the e.g. b).
     * @param assignable
     * @return
     */
    private IScope getScopeForAssignable(EObject assignable) {
    	final var name = ((Referenceable) assignable).getName();
		if (name == null) { // name might be null, e.g. for TableAccess with unresolvable indexExpression
			// TODO: return placeholder object or implement trivial recovery
			// TODO: name should not be null anymore, since TableAccesses get a dummy name?
			return IScope.NULLSCOPE;
		}
		
    	final var fqn = nameConverter.toQualifiedName(name);
    	final var value = LinkingAndScopingUtils.findAssignedExp((Feature) assignable);
		if (value == null) {
			// create synthetic nil value if ExpList does not contains value for assignable
			var nilValue = new SyntheticExpNil();
			var nilValueDescription = EObjectDescription.create(fqn, nilValue);
			return new SimpleScope(Collections.singletonList(nilValueDescription));
		} else {
			// any assignable is also a Referenceable which has a name attribute and a
			// cross-reference with linkText == name

			// we create a description with the name of the assignable and the value expression
			// => the scope for the assignable contains only this description
			var assignedValueDescription = EObjectDescription.create(fqn, value);
			return new SimpleScope(Collections.singletonList(assignedValueDescription));
		}
    }

    private List<Referenceable> getCandidatesFromAssignablesFor(EObject context, QualifiedName fqn) {
    	var rootElement = EcoreUtil2.getRootContainer(context);
    	var assignments = EcoreUtil2.getAllContentsOfType(rootElement, Assignment.class);
    	return assignments.stream()
				 .map(assignment ->  EcoreUtil2.getAllContentsOfType(assignment, Referenceable.class))
				 .flatMap(List::stream)
				 .filter(obj -> LinkingAndScopingUtils.isAssignable(obj))
				 .filter(refble ->  fqn.equals(qualifiedNameProvider.getFullyQualifiedName(refble)))
				 .toList();
    }
    
    // find table contents for "context = table" assignment:
    /*
     * 1. find last declaration of table before the context line
     * 2. find first declaration of table after context line (if any)
     * 3. build table from all declarations between 1. and 2.
     * 4. ????
     * 5. profit.
     */
    
    private Collection<IEObjectDescription> findCandidatesForFeature(Feature context, EObject scopeRoot) {
    	var candidates = new ArrayList<IEObjectDescription>();
    	
    	var contextFqn = qualifiedNameProvider.getFullyQualifiedName(context);
    	var assignments = EcoreUtil2.getAllContentsOfType(scopeRoot, Assignment.class);
    	// function findCandidatesInPathByFqn(fqn) that searches for feature candidates by fqn:
    	// 1. find all candidates with contextFqn.startsWith(candidateFqn)
    	// 2. filter by: candidate.pointsToTable() || contextFqn.equals(candidateFqn)
    	// 3. forall candidates if pointsToTable: 
        //    3.1 newFqnHead = candidate.getRef().getFqn()  // quit here if cannot be resolved
    	//    3.2 contextFqnTail = contextFqn.remove(candidateFqn)
    	//    3.3 furtherCandidates = findCandidatesInPathByFqn(newFqnHead + contextFqnTail)
    	// 	  3.4 add result as description with (candidate.getFqn() + contextFqnTail, furtherCandidate)
    	// 4. return candidates
    	assignments.stream()
				 .map(assignment ->  EcoreUtil2.getAllContentsOfType(assignment, Referenceable.class))
				 .flatMap(List::stream)
				 .filter(obj -> LinkingAndScopingUtils.isAssignable(obj))
				 .filter(refble ->  contextFqn.equals(qualifiedNameProvider.getFullyQualifiedName(refble)))
				 .toList();
    	
    	return candidates;
    }
    
    private Collection<Referenceable> getAssignablesFromFor(final EObject scopeRoot, final EObject context) {
    	var assignments = EcoreUtil2.getAllContentsOfType(scopeRoot, Assignment.class);
    	return assignments.stream()
    			 .filter(assignment -> !EcoreUtil2.getAllContentsOfType(assignment, context.getClass()).contains(context))
				 .map(assignment ->  EcoreUtil2.getAllContentsOfType(assignment, Referenceable.class))
				 .flatMap(List::stream)
				 .filter(obj -> LinkingAndScopingUtils.isAssignable(obj))
				 .toList();
    }
    
    
    
    
    // TODO:
    //  - made some quick changes to avoid returning parent assignment assignables when searching for assignables
    //  - need to check the arguments of the recursive call of the method below, where context is passed (check if context is the correct argument)
    //  - check grammar: serialization does not work anymore
    //  - re-inserted the recursion in the method below, I think the stackoverflow error was fixed before that
    //    or does not appear without it
    
    
    
	// function findCandidatesInPathForFqn(fqn) that searches for feature candidates by fqn:
	// 1. Add all candidates with contextFqn.equals(candidateFqn) to result
    // 2.1 find all candidates with contextFqn.startsWith(candidateFqn)
	// 2.2 filter by: candidate.pointsToTable() 
	// 3. forall candidates if pointsToTable: 
    //    3.1 newFqnHead = candidate.getRef().getFqn()  // quit here if cannot be resolved
	//    3.2 contextFqnTail = contextFqn.remove(candidateFqn)
	//    3.3 furtherCandidates = findCandidatesInPathByFqn(newFqnHead + contextFqnTail)
	// 	  3.4 add result as description with (candidate.getFqn() + contextFqnTail, furtherCandidate)
	// 4. return candidates
    private Collection<Referenceable> findCandidatesInPathForFqn(QualifiedName contextFqn, final EObject context, final EObject scopeRoot) {
    	var assignables = getAssignablesFromFor(scopeRoot, context);
    	
    	var result = new ArrayList<Referenceable>();
    	for (final var assignable : assignables) {
    		
    		//QualifiedName assignableFqn = null;
    		
    		if (LinkingAndScopingUtils.isTableAccessWithDummyName(assignable)) {
    			var ta = (TableAccess) assignable;
    			
    			// TODO: this already leads to the error:  ERROR xt.linking.lazy.LazyLinkingResource  - Cyclic resolution of lazy links : Referencing.ref->Referencing.ref in resource '__synthetic0.lua'.
    			//var name = LinkingAndScopingUtils.tryResolveExpressionToString(ta.getIndexExp());
    			//System.out.println()
    			
    			//if (name == null) continue;
    			
    			//var taDummyFqn = qualifiedNameProvider.getFullyQualifiedName(ta);
	        	//var candidatesName = taDummyFqn.toString().replace(LinkingAndScopingUtils.DUMMY_NAME, name);
	        	//var assignableFqn = nameConverter.toQualifiedName(candidatesName);
	        	//System.out.println(assignable);
	        	//System.out.println("foo: " + assignableFqn);
    			
    			//System.out.println("booo");
    			//ta.setName(LinkingAndScopingUtils.SYNTHETIC_NAME);
    			//var val = ta.getRef();
    			//System.out.println(val);
    			//var name = LinkingAndScopingUtils.tryResolveExpressionToString(ta.getIndexExp());
    			//if (name != null) {
    			//	ta.setName(name);
    				//ta.setRef(ta.getRef());
    				//ta.setRef(val);
    			//}
    			
    			//continue;
    			

    		}// else {
    		//	assignableFqn = qualifiedNameProvider.getFullyQualifiedName(assignable);
    		//}
    		
    		final var assignableFqn = qualifiedNameProvider.getFullyQualifiedName(assignable);
    		//System.out.println("foo: " + assignableFqn);
    		
    		if (contextFqn.equals(assignableFqn)) { // add all assignables with equal fqn
    			result.add(assignable);
    		//} else if (contextFqn.toString().startsWith(assignableFqn.toString())) {
    		} else if (contextFqn.startsWith(assignableFqn)) {
    			
    			final var assignedValue = LinkingAndScopingUtils.tryGetAssignedValueFrom((Referencing) assignable); // value of assignable (is not Referencing)
        		final var assignedRef = (((Referencing) assignable).getRef()); // rhs of assignable (might be a Referencing)
        		

    			
        		if (assignedValue instanceof TableConstructor && assignedRef instanceof Referencing) {
        			//var fqnHead = qualifiedNameProvider.getFullyQualifiedName(assignedValue);
        			var newFqnHead = qualifiedNameProvider.getFullyQualifiedName(assignedRef);
        			var newFqnTail = getFqnTail(contextFqn, assignableFqn.getSegmentCount());
        			var newFqn = concatFqns(newFqnHead, newFqnTail);
        			
        			result.addAll(findCandidatesInPathForFqn(newFqn, context, scopeRoot)
        				.stream()
        				.toList()
        			);
        			
        		}
        		
    		}
    	}

    	return result;

    }
    
    private QualifiedName getFqnTail(QualifiedName forFqn, int startIndex) {
    	var resultSegments = new ArrayList<String>();
    	for (var i = 0; i < forFqn.getSegmentCount(); i++) {
    		if (i >= startIndex) {
    			resultSegments.add(forFqn.getSegment(i));
    		}
    	}
    	
    	if (resultSegments.isEmpty()) {
    		throw new RuntimeException("Cannot get tail for " + forFqn + " with startIndex " + startIndex + "!");
    	}
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (int i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    private QualifiedName concatFqns(QualifiedName fqn1, QualifiedName fqn2) {
    	var resultSegments = new ArrayList<>(fqn1.getSegments());
    	resultSegments.addAll(fqn2.getSegments());
    	
    	if (resultSegments.isEmpty()) return null;
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (var i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    /**
     * For MemberAccess (e.g. a.member), we need to remove the quotes from the candidates name,
     * since the candidates may be TableAccesses with StringLiterals as indexExp, which have leading and trailing quotes,
     * see LuaQualifiedNameProvider). </br>
     * 
     * E.g. MemberAccess "member" in "a.member" has name "member", while candidate a["member"] has the name ""member"".
     * @param candidates
     * @return
     */
    private Collection<IEObjectDescription> createDescriptionsForMemberAccess(Collection<Referenceable> candidates) {
    	return candidates.stream()
				 .map(c -> 
				 	EObjectDescription.create(
						 LinkingAndScopingUtils.removeQuotesFromString(c.getName()),
						 c
					)
				 )
				 .toList();
    }    
    
    /**
     * We always need to create descriptions (instead of returning Scopes.scopeFor(candidates)), since the 
     * candidates name might contain ".", which would fail to match the QualifiedName generated from the cross-reference
     * in the DefaultLinkingService.</br>
     * This is because the qualifiedNameConverter uses "." to separate Strings, i.e.
     * the generated cross-reference QualifiedName for "hello.world" would be "hello" "world", which would not match
     * the candidate's name "hello.world".</br></br>
     * 
     * An alternative would be to extend the IQualifiedNameConverter.DefaultImpl and change/remove the delimiter.
     * @param candidates The candidates.
     * @return A list of EObjectDescriptions of the candidates, created by applying the qualifiedNameConverter to the candidate's name attribute.
     */
    private Collection<IEObjectDescription> createDescriptionsForCandidates(Collection<Referenceable> candidates) {
    	return candidates.stream()
    				.map(c -> EObjectDescription.create(nameConverter.toQualifiedName(c.getName()), c))
    				.toList();
    }

   
    
}
