// Grammar for Lua 5.2
grammar org.xtext.lua52.Lua52 
	hidden(WS, COMMENT)
	
	
// 	Now inlined because of INT not being matchable // TODO: check this out, legacy from base Lua grammar from Burgey
//	with org.eclipse.xtext.common.Terminals 
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore	
generate lua52 "http://www.xtext.org/lua52/Lua52"


/**
 * Grammar is based on the reference grammar given at https://www.lua.org/manual/5.2/manual.html#9 "9 – The Complete Syntax of Lua"
 * and based on the xText implementation of the Lua 5.1 grammar.
 */

// TODO: might need to re-insert FunctionCall and Assignment as classes for later scoping/linking steps.
// TODO: document differences between reference grammar and the implemented one (LLk, i.e. no left recursion and no ambiguities).

// TODO: Lua long string literals (also used for comments)
// TODO: currently, something like a=10r30 is possible ("r30" is detected as a functioncall directly after the last right-side-expression of an assignment), not sure how to fix
// TODO: Single-line comments start with -- NOT followed by a LUA_STRING_LONG (else its a multiline comment), this currently does not work

// A shebang (#!) at the beginning of a lua script is possible in lua but can not (currently) be parsed by this grammar, i.e. if the first line starts with '#' is is considered a comment

Chunk:
	//SPECIAL_COMMENT?
	block=Block
;

//terminal SPECIAL_COMMENT:
//	('#' -> '\n')
//;

Block: 
	{Block} (stats+=Stat (=>';')?)* (lastStat=LastStat (=>';')?)? 
;

/**
 * We need to define actions here to differentiate between e.g. different loops:
 * E.g.: If Stat contains the alternatives
    'while' condition=Exp 'do' block=Block 'end' |
    'repeat' block=Block 'until' condition=Exp
 * without actions (i.e. {WhileLoop}, {RepeatLoop}) the serialization would create a while-loop when the original contained a repeat-loop.
 */
Stat returns Stat:
	AssignmentOrFunctionCall |
    {DoEndBlock} 'do' block=Block 'end' |
    {WhileLoop} 'while' condition=Exp 'do' block=Block 'end' |
    {RepeatLoop}'repeat' block=Block 'until' condition=Exp |
    {IfThenElse} 'if' condition=Exp 'then' thenBlock=Block (elseIfs+=ElseIf)* ('else' elseBlock=Block)? 'end' |
    {NumericFor} 'for' LUA_NAME '=' fromExp=Exp ',' toExp=Exp (',' stepExp=Exp)? 'do' block=Block 'end' |
    {GenericFor} 'for' forArgs=NameList 'in' expList=ExpList 'do' block=Block 'end' |
    {FunctionDeclaration} 'function' funcName=FuncName body=FuncBody |
    {LocalFunctionDeclaration} 'local' 'function' LUA_NAME body=FuncBody |
    {LocalNameListDeclaration} 'local' vars=NameList ('=' expList=ExpList)? 
    | Lua52Stat
;

/**
 * Initially, the idea was to create a new xText grammar for Lua5.2, extending the Lua5.1 grammar.
 * Unfortunately, the AssignmentOrFunctionCall Production rule prevents the extension in a sensible way, since large parts of this grammar (Lua5.1)
 * would need to be duplicated in the extension (see https://github.com/eclipse/xtext/issues/2593).
 * 
 * Should this issue be resolved in the future, the extension can be created as explained here: https://stackoverflow.com/questions/16442508/including-a-grammar-into-another-grammar.
 * The extension grammar could then contain something along the lines of the following:
 * 
   @Override 
	Stat:
		super |
    	{Goto} 'goto' label=LUA_NAME |
		{Label} '::' label=LUA_NAME '::'
	; 
	//[...]
 */

Lua52Stat returns Stat:
	{Stat} ';' |
	{Goto} 'goto' label=LUA_NAME |
	{Label} '::' label=LUA_NAME '::'
;

/**
 * Explanation for AssignmentOrFunctionCall rule:
 * Previously, we had something like this (as a result from removing left-recursion and ambiguities from the reference grammar):
 		Stat:
 			FunctionCall |
 			Assignment 
 		;
 		
		Assignment:
			varList=VarList '=' expList=ExpList
		;              //    ^ this is the '=' that needs to be reached to differentiate between a PrefixExp matching a Var and a PrefixExp matching a FunctionCall.
		
		VarList returns VarList:
			vars+=Var (',' vars+=Var)*
		;
		* 
		FunctionCall: 
			PrefixExp
		;
		* 
		Var returns Var: 
		    PrefixExp
		;
 * We need to differentiate between a FunctionCall and an Assignment, since the xTexts/ANTLRs lookahead is not able to reach the '=' to do so.
 * Ref. for the fix: https://dslmeinte.wordpress.com/2014/09/11/ambiguitiy-in-xtext-grammars-part-2/
 */
//HeadTarget: FunctionCall | Assignment;	
//Named: FunctionCall | Assignment ;
//Head: PrefixExp;
AssignmentOrFunctionCall returns Stat:
	PrefixExp (
		({FunctionCall.functionCall=current}) |
	   	({Assignment.vars+=current} (',' vars+=PrefixExp)* =>'=' expList=ExpList)
	)
;


//Assignment:
//	varList=VarList '=' expList=ExpList
//;

//VarList returns VarList:
//	vars+=Var (',' vars+=Var)*
//;

ElseIf:
	'elseif' condition=Exp 'then' block=Block
;

LastStat: 
	{LastStat} 'return' (expList=ExpList)? |
    {LastStat} 'break'
;


Ref:
	name=LUA_NAME
;


//Arg:
//	name=LUA_NAME
//;

// Expressions

ExpList: 
	// TODO: the previous alternative: (exps+=Exp ',')* exps+=Exp caused a non-LL(*) error due to recursive rule invocations, find out why
	//(=>exps+=Exp ',')* exps+=Exp
	//=>(exps+=Exp ',')* exps+=Exp 
	 exps+=Exp ( =>',' exps+=Exp)*
;

Exp:
	ExpOr
;
 
// Or: left associative, priority 0
ExpOr returns Exp:
	ExpAnd ('or' {ExpOr.left=current} right=ExpAnd)*
	//Exp_Primary ('or' {Exp_Or.left=current} right=Exp_Primary)*
;

// And: left associative, priority 1
ExpAnd returns Exp:
	ExpCompare ('and' {ExpAnd.left=current} right=ExpCompare)*;

// Comparisons: left associative, priority 2
ExpCompare returns Exp:
	ExpConcat (('>' {ExpGt.left=current} right=ExpConcat) |
	('>=' {ExpGeq.left=current} right=ExpConcat) |
	('<' {ExpLt.left=current} right=ExpConcat) |
	('<=' {ExpLeq.left=current} right=ExpConcat) |
	('==' {ExpEq.left=current} right=ExpConcat) |
	('~=' {ExpNeq.left=current} right=ExpConcat))*;

// Concatenation: right associative, priority 3
ExpConcat returns Exp:
	ExpAddSub ('..' {ExpConcat.left=current} right=ExpConcat)?;

// addition/subtraction: left associative, priority 4
ExpAddSub returns Exp:
	ExpMultDivMod (('+' {ExpAdd.left=current} right=ExpMultDivMod) |
	('-' {ExpSub.left=current} right=ExpMultDivMod))*;

// multiplication/division, left associative, priority 5
ExpMultDivMod returns Exp:
	ExpUnary (('*' {ExpMult.left=current} right=ExpUnary) |
	('/' {ExpDiv.left=current} right=ExpUnary) |
	('%' {ExpMod.left=current} right=ExpUnary))*;

// Unary operators: right associative, priority 6
ExpUnary returns Exp:
	ExpExponentiation |
	('not' {ExpNegate} exp=ExpUnary) |
	('#' {ExpLength} exp=ExpUnary) |
	('-' {ExpInvert} exp=ExpUnary);

// exponentiation: right associative, priority 7
ExpExponentiation returns Exp:
	ExpPrimary ('^' {ExpExponentiation.left=current} right=ExpUnary)?
;
 
ExpPrimary returns Exp:
	{ExpNil} 'nil' | 
	{ExpFalse} 'false' | 
	{ExpTrue} 'true' | 
	{ExpNumberLiteral} value=NUMBER_LITERAL | 
	{ExpStringLiteral} value=LUA_STRING | 
	{ExpVarArgs} '...' |
	FunctionDeclaration |
	PrefixExp |
	TableConstructor
	// exp binop exp | unop exp from the reference are handled without left-recursion and describing operator precedences by Exp starting with ExpOr
;


// Just for readability/mapping to the reference: the rule chain starting from SuffixExp parses the prefix
// expressions from the reference documentation.
PrefixExp returns Exp:
	SuffixExp
;

SuffixExp returns Exp:
	Var =>(
		':' {MemberFuncCall.object=current} funcName=LUA_NAME args=Args |
		{FuncCall.object=current} args=Args |
		'[' {VarArrayAccess.array=current} index=Exp ']' |
		'.' {VarMemberAccess.object=current} memberName=LUA_NAME
	)*
;

// PrefixExp now executed last in expression chain to avoid left-recursion
Var returns Exp:
	'(' Exp ')' |
	{Var} var=LUA_NAME
;

Args: 
	{ParamArgs} '(' (params=ExpList)? ')' | 
	//{ParamArgs} '(' (params=[ExpList|NameList])? ')' | 
	TableConstructor |
	{LiteralStringArg} str=LUA_STRING 
;

TableConstructor:
	{TableConstructor} '{' (fieldList=FieldList)? '}'
;

//FieldList:
//	fields+=Field (FIELD_SEP fields+=Field)* (FIELD_SEP)?
//;

FieldList:
	fields+=Field (=>(','|';') fields+=Field)* (=>(','|';'))? 
;

Field:
	'[' indexExp=Exp ']' '=' valueExp=Exp | 
	LUA_NAME '=' valueExp=Exp | 
	Exp
;

FuncName:
	LUA_NAME ('.' LUA_NAME)* (':' LUA_NAME)?
;

NameList: 
	LUA_NAME (',' LUA_NAME)*
;

FunctionDeclaration:
	'function' FuncBody
;

FuncBody:
	'(' (ParList)? ')' funcBlock=Block 'end'
;

ParList:
	NameList (',' '...')? |
	'...'
;




// ****************************************************
// TERMINALS
// ****************************************************

// Identifiers can be any string of letters, digits, and underscores, but mustn't begin with a digit.
terminal LUA_NAME returns ecore::EString:
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;


// Literal Strings can be defined between single or double quotes. They can also be defined using a long format enclosed by long brackets.
// https://www.lua.org/manual/5.1/manual.html#2.1 ("2.1 – Lexical Conventions")
// E.g. [[...]], [=[...]=]
terminal LUA_STRING:
	'"' ('\\' . | !('\\' | '"'))* '"' |
	"'" ('\\' . | !('\\' | "'"))* "'"  
	| LUA_STRING_LONG
;

/* TODO: this is a workaround, long strings should be implemented for an arbitrary number of equals-signs. Attempt below failed. */
terminal LUA_STRING_LONG:
	'[[' -> ']]'  |
	'[=[' -> ']=]' |
	'[==[' -> ']==]' |
	'[===[' -> ']===]' |
	'[====[' -> ']====]' |
	'[=====[' -> ']=====]' |
	'[======[' -> ']======]' |
	'[=======[' -> ']=======]' 
;

// Attempt to implement long strings for arbitrary number of equal signs:
/*
terminal LUA_STRING_LONG:
	'[' LUA_STRING_LONG_CONTENT ']'
;

terminal LUA_STRING_LONG_CONTENT:
	//'[' -> ']' |
	'=' LUA_STRING_LONG_CONTENT '='
	| '[' (.)* ']'
;
*/

/**
 *  From https://www.lua.org/manual/5.1/manual.html#2.1:
 * 
 * "A comment starts with a double hyphen (--) anywhere outside a string. If the text immediately after -- is not an opening long bracket, 
 * the comment is a short comment, which runs until the end of the line. Otherwise, it is a long comment, which runs until the corresponding 
 * closing long bracket. Long comments are frequently used to disable code temporarily."
 * 
 * This implies just one '[' suffices to start a multiline comment, but it seems two are needed.
 */
terminal COMMENT:
	ML_COMMENT | SL_COMMENT
;

terminal ML_COMMENT:
	'--' LUA_STRING_LONG
;
 
terminal fragment MATCH_UNTIL_LINE_BREAK:
	!('\n'|'\r')* ('\r'? '\n')?
;

terminal SL_COMMENT:
	'--' !'[' MATCH_UNTIL_LINE_BREAK |
	'--[' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[=' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[==' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[===' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[====' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[=====' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[======' !('['|'=') MATCH_UNTIL_LINE_BREAK |
	'--[=======' !('['|'=') MATCH_UNTIL_LINE_BREAK 	
;

terminal NUMBER_LITERAL returns ecore::EDouble:
	// rules for double values
	(
		('0'..'9')+ | //Int rule
		('0'..'9')+ '.' ('0'..'9')* | // real rule with int part
		'.' ('0'..'9')+ // real with only decimal places
	)
	(('e'|'E') ('+'|'-')? ('0'..'9')+)? // exponent part 
	
	// rules for hex values
	| HEX_LITERAL
;

// hex rules differ from Lua 5.1 (allow uppercase 'X' and 'A'..'F', fractional part and exponent part)
terminal HEX_LITERAL returns ecore::EDouble:
	( ('0x' | '0X') 
		(
			('0'..'9' | 'a'..'f' | 'A'..'F')+ | //Int rule
			('0'..'9' | 'a'..'f' | 'A'..'F')+ '.' ('0'..'9' | 'a'..'f' | 'A'..'F')* | // real rule with int part
			'.' ('0'..'9' | 'a'..'f' | 'A'..'F')+ // real with only decimal places
		)
	) (('p'| 'P') ('+'|'-')? ('0'..'9')+)? // the exponent part, should be binary per definition but here we just allow any int
;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+; // Consume all white space, tabs and new line characters
	

