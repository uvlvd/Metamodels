/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.lua.lua.Chunk
import org.eclipse.emf.ecore.EObject
import java.io.ByteArrayOutputStream
import org.xtext.lua.PreprocessingUtils
import org.eclipse.xtext.resource.DerivedStateAwareResource

@ExtendWith(InjectionExtension)
@InjectWith(LuaInjectorProvider)
class LuaScopingTest {
	@Inject
	ParseHelper<Chunk> parseHelper
	
	
	def static String dump(EObject mod_, String indent) {
	    //var res = indent + mod_.toString.replaceFirst ('.*[.]impl[.](.*)Impl[^(]*', '$1 ')
	 	var res = indent + mod_.toString.replaceFirst ('.*[.]impl[.](.*)Impl[@](.*)[^(]*', '$1 $2')
	    for (a :mod_.eCrossReferences) 
	        //res += ' ->' + a.toString().replaceFirst ('.*[.]impl[.](.*)Impl[^(]*', '$1 ')
	        res += ' ->' + a.toString().replaceFirst ('.*[.]impl[.](.*)Impl[@](.*)[^(]*', '$1 $2')
	    res += "\n"
	    for (f :mod_.eContents) {
	        res += f.dump (indent+"    ")
	    }
	    return res
	}
	
	def void check(Chunk chunk, String original, Boolean expectedToFail) {
		if (!expectedToFail) {
			check(chunk, original)
			return
		}
		
		Assertions.assertNotNull(chunk)
		val errors = chunk.eResource.errors
		Assertions.assertFalse(errors.isEmpty)
	}	

	def void check(Chunk chunk, String original) {
		Assertions.assertNotNull(chunk)
		val errors = chunk.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
		checkEquality(chunk, original)
	}
	
	def void checkEquality(Chunk chunk, String original) {
		val outputStream = new ByteArrayOutputStream()
		chunk.eResource.save(outputStream, #{})
		val parsedAndPrinted = outputStream.toString()
		
		val origExtremelyCanonical = removeComments(original)
		val parsedAndPrintedExtremelyCanonical = removeComments(parsedAndPrinted)

		val equivalence = origExtremelyCanonical.equals(parsedAndPrintedExtremelyCanonical)
		if (!equivalence) {
			System.out.println("===== Original: =====")
			System.out.println(original)
			System.out.println("===== Parsed and serialized: =====")
			System.out.println(parsedAndPrinted)
			
			System.out.println("===== Original canonical (extremely so): =====")
			System.out.println(origExtremelyCanonical)
			System.out.println("===== Parsed and serialized canonical: =====")
			System.out.println(parsedAndPrintedExtremelyCanonical)
		}
		Assertions.assertTrue(equivalence)
	}
	
	// TODO: rename, it replaces all whitespace also
	def String removeComments(String string) {
		val withoutComments = PreprocessingUtils.removeComments(string)
		return PreprocessingUtils.removeAllWhiteSpacesAndNewLines(withoutComments)	 
	}
	
	
	
	
	
	@Test
	def void scopingTest() { 
		val SUT = '''
			a = 1
			b = a
			
			--for num = 1, 10 do
			--	a = a + num
			--end
			
			--for i, j in {1,2,3}, {4,5,6} do
			--	b = i+j
			--end
			--test.member[1].func()[2].field = 1
			--var = 1
			--a = var
			--a.b, a = 2, 3
			--a = 10
			--b = a
			--test.member[1] = t.member[1]
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingMemberTest() { 
		val SUT = '''
			l = {}
		    l.member, k, j = 10, 11, 12
			a = {}
			a.member = {}
			a.member.secondMember = 10
			b = a
			c = a.member
			d = a.member.secondMember
			x, y = l.member, a.member
			
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingTableAccessStringLiteralTest() { 
		val SUT = '''
			a = {}
		    a["member"] = 1
		    b = a["member"]
		    c = a.member
		    str = "member" 
		    --a[str] = 1 --TODO
		    --f = a.member
		    --str2 = "2"
		    d = a[str]
		   -- a["hello.world"] = 2
		   -- b = a["hello.world"]
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingTableAccessNumberLiteralTest() { 
		val SUT = '''
			a = {}
		    a[0] = 2
		    b = a[0]
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	
	
	/**
	 *  d should be resolvable to 1, e.g.
	 *  d -> a (in line 4), which contains [str], which points to a["member"], which points to 1.
	 */
	@Test
	def void scopingTableAccessStringLiteralVariableTest() { 
		val SUT = '''
			a = {}
		    a["member"] = 1
		    str = "member" 
		    d = a[str] 
		'''
		val result = parseHelper.parse(SUT)

		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingTableAccessNumberLiteralVariableTest() { 
		val SUT = '''
			a = {}
		    a[0] = 1
		    str = 0 
		    d = a[str] 
		'''
		val result = parseHelper.parse(SUT)

		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingFunctionDeclarationTest() { 
		val SUT = '''
			a = {}
			function func() end
			function a.func2() end
			b = func
			c = a.func2
			t = function(key) key = key:lower() end
				
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingMissingValueInExpressionTest() { 
		val SUT = '''
			a, b = 1 -- b should reference a newly created ExpNil
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingLastAssignmentTest() { 
		val SUT = '''
			a = 1
			a = 2
			a = 3
			b = a -- b should reference a from a=3
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
		def void scopingPartialTableAccessTest() { 
		val SUT = '''
			b = {}
			b.temp = 1 
			a = {}
			a.b = b
			c = a.b.temp
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	
	@Test
	def void scopingTempTest() { 
		val SUT = '''
			a = {}
			--a["member"] = {}
			--a["member"].b = "b"
			--a[1+1] = "temps" --TODO
			--b = a["member"]
			--c = a.member
			str = "member" 
			a[str] = 1 --TODO
			f = a.member
			--d = a[str]
		
			--b = {}
			--b.temp = 1 
			--a = {}
			--a.b = b
			--c = a.b.temp
			
			
			--func = function () return 0 end
			--a = {}
		   -- a[0] = 2
		   -- b = a[func()]
		   -- a[func()] = 1
		   -- str = "member"
		   -- a[str] = 1
		   -- c = a.member
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	
	// TODO: never allow a rhs to reference its own lhs, 
	// needs to be lhs of other Assignment
	@Test
	def void scopingTemp3Test() { 
		val SUT = '''
			


    for i = 2, narg do
        local is_key = false
        if key_finder then
            is_key = key_finder(i, narg)
        end

        local n, err = read_len(sk)
        if not n then
            return nil, err
        end

        local s
        if not is_key and n > MAX_VALUE_LEN then
            -- avoid recording big value
            local p, err = sk:read(MAX_VALUE_LEN)
            if not p then
                return nil, err
            end

            local ok, err = sk:drain(n - MAX_VALUE_LEN + 2)
            if not ok then
                return nil, err
            end

            s = ffi_str(p, MAX_VALUE_LEN) .. "...(" .. n .. " bytes)"
        else
            local p, err = sk:read(n + 2)
            if not p then
                return nil, err
            end

            s = ffi_str(p, n)

            if is_key and matcher.keys[s] then
                matcher = matcher.keys[s]
                key_finder = nil
            end
        end

        cmd_line[i] = s
    end

    if matcher then
        if matcher.keys then
            -- try to match any key of this command
            matcher = matcher.keys["*"]
        end

        if matcher then
            sleep(matcher.delay)
        end
    end

end
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
	@Test
	def void scopingTemp2Test() { 
		val SUT = '''

		a = {
		      send = function(self, ...)
		          if select('#', ...) == 1 and type(select(1, ...)) == "string" then
		              -- fast path
		              return self.sock:send(...)
		          end
		  
		          -- luasocket's send only accepts a single string
		          return self.sock:send(flatten({...}))
		      end,
		  
		      getreusedtimes = function ()
		          return 0
		      end
		      }
		      
		'''
		val result = parseHelper.parse(SUT)
		System.out.println(dump(result, ""));
		check(result, SUT)
	}
	
}
