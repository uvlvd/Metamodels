/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.scoping;

import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.linking.impl.LinkingHelper;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.lua.lua.Assignment;
import org.xtext.lua.lua.Block;
import org.xtext.lua.lua.ExpList;
import org.xtext.lua.lua.LuaPackage.Literals;
import org.xtext.lua.lua.MemberAccess;
import org.xtext.lua.lua.Stat;
import org.xtext.lua.lua.Var;

import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class LuaScopeProvider extends AbstractLuaScopeProvider {
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	
  	@Inject
    private IQualifiedNameConverter nameConverter;
  	
	@Inject 
	private LinkingHelper linkingHelper;
    
    @Override
    public IScope getScope(final EObject context, final EReference reference) {
        if (context == null) {
            // nothing todo without context
            return IScope.NULLSCOPE;
        }
        
        // TODO: the getScopeFor...() functions need to get a parentScope passed or they will match anything in the model
        if (context instanceof Var var) {
        	//System.out.println("Getting scope for Var...");
        	return getScopeForVar(var, reference);
        }
        
        if (context instanceof MemberAccess memberAccess) {
        	//System.out.println("Getting scope for var MemberAccess...");
        	return getScopeForMemberAccess(memberAccess, reference);
        }
        

        var parentBlock = EcoreUtil2.getContainerOfType(context.eContainer(), Block.class);
        if (parentBlock == null) {
            // if we have no parent anymore we delegate to the global scope
        	//System.out.println("TODO: Implement global scope");
        	//System.out.println(context);
        	return super.getScope(context, reference); // TODO: just for debug, remove
            //return super.getGlobalScope(context.eResource(), reference);
        }
        
        //System.out.println("current context: " + context);
        //System.out.println("context parent: " + context.eContainer());
        var parentStatement = EcoreUtil2.getContainerOfType(context, Stat.class);
        //var blockScope = getScopeOfBlock(parentBlock, context, parentStatement, reference);
        //return blockScope;
        return super.getScope(context, reference); // TODO: just for debug, remove
    }
    
    private IScope getScopeForVar(final Var var, final EReference reference) {
    	// get candidates, i.e. all lhs-objects of the same type and with a name matching the reference
    		 // TODO: only traverse parent scope, should not need to traverse whole tree
    		//        maybe even only those VarMemberAccessLhs for which eContainer() is of an appropriate type? (i.e. if there type of candidate.eContainer and memberAccess.eContainer differ
    		//		  the candidate cant be a candidate?
    	var rootElement = EcoreUtil2.getRootContainer(var);
    	var assignments = EcoreUtil2.getAllContentsOfType(rootElement, Assignment.class);
    	List<Var> candidates = assignments.stream()
    								 .map(Assignment::eContents) // all direct children of assignments
    								 .flatMap(List::stream) // flatten lists -> on list of direct assignment children
    								 .filter(obj -> (obj instanceof Var)) // Vars that are direct children do not have suffixes
    								 .map(obj -> (Var) obj)
    								 .toList();
    	   	
    	


    	
    	//var descriptions = new ArrayList<IEObjectDescription>();
        //var fqn = qualifiedNameProvider.apply(refble);
    	
    	if (candidates.size() != 0) {
    		//System.out.println(candidates);
    		// TODO: this scope should probably get the parentScope as parameter instead of IScope.NULLSCOPE
    		return createScopeForCandidates(candidates);
    	} else {
    		//System.out.println(candidates);
    	}
    	
    	return IScope.NULLSCOPE;
    }
    
    private IScope getScopeForMemberAccess(final MemberAccess memberAccess, final EReference reference) {
    	// get candidates, i.e. all lhs-objects of the same type and with a name matching the reference
    		 // TODO: only traverse parent scope, should not need to traverse whole tree
    		//        maybe even only those VarMemberAccessLhs for which eContainer() is of an appropriate type? (i.e. if there type of candidate.eContainer and memberAccess.eContainer differ
    		//		  the candidate cant be a candidate?
    	var rootElement = EcoreUtil2.getRootContainer(memberAccess);
    	var assignments = EcoreUtil2.getAllContentsOfType(rootElement, Assignment.class);
    	List<EObject> lhsPrefixes = assignments.stream()
    								 .map(Assignment::eContents)
    								 .flatMap(List::stream)
    								 .filter(obj -> !(obj instanceof ExpList))
    								 .toList();
    	
    	// TODO: this is only temporary, all lhsPrefixes are candidates (or at least the ones with the type calling this function)
    	var allCandidates =  lhsPrefixes.stream().filter(obj -> (obj instanceof MemberAccess)).map(obj -> (MemberAccess) obj).toList();
    	
    	
    	//var candidates = EcoreUtil2.getAllContentsOfType(rootElement, MemberAccess.class)
    	//						   .stream()
    	//						   .filter(candidate -> isPathsEqual(candidate, memberAccess))
    	//						   .toList();
    	var candidates = allCandidates.stream().filter(candidate -> isPathsEqual(candidate, memberAccess)).toList();
    	
    	if (candidates.size() != 0) {
    		//System.out.println(candidates);
    		return createScopeForCandidates(candidates);
    	} else {
    		//System.out.println(candidates);
    	}
    	
    	return IScope.NULLSCOPE;
    }
    
    //TODO: should probably return a SimpleScope based on the parentScope, not IScope.NULLSCOPE?
    private IScope createScopeForCandidates(List<? extends EObject> candidates) {
    	var descriptions = candidates.stream()
				 .map(candidate -> {
					 var fqn = qualifiedNameProvider.apply(candidate); // TODO: throw error here if null, explaining that the LuaQualifiedNameProvider needs to be updated for all EObjects
			    	 return EObjectDescription.create(fqn, candidate);
				 })
				 .toList();
    	return new SimpleScope(IScope.NULLSCOPE, descriptions);
    }
    	
    	
    private boolean isPathsEqual(final MemberAccess lhs, final MemberAccess rhs) {
    	var refNode = NodeModelUtils.findNodesForFeature(rhs, Literals.MEMBER_ACCESS__NAME).get(0);
    	var refString = linkingHelper.getCrossRefNodeAsString(refNode, true);
    	
    	var lhsNode = NodeModelUtils.findNodesForFeature(lhs, Literals.MEMBER_ACCESS__NAME).get(0);
    	var lhsString = linkingHelper.getCrossRefNodeAsString(lhsNode, true);
    	//System.out.println("	Comparing " + lhsString + " and " + refString);
    	// early out 1: currently compared path elements are not equal
    	if (!lhsString.equals(refString)) { 
    		//System.out.println("	1:" + lhs.getName() + ", " + refString);
    		return false;
    	}
    	
    	var lhsChild = getSingleChild(lhs);
    	var rhsChild = getSingleChild(rhs);
    	
    	// end: found leaf elements for both paths, return comparison of leaf elements
    	if (lhsChild instanceof Var lhsVar && rhsChild instanceof Var rhsVar) {
    		var refChildNode = NodeModelUtils.findNodesForFeature(rhsVar, Literals.VAR__NAME).get(0);
	    	var refChildString = linkingHelper.getCrossRefNodeAsString(refChildNode, true);
	    	
	    	var lhsChildNode = NodeModelUtils.findNodesForFeature(lhsVar, Literals.VAR__NAME).get(0);
	    	var lhsChildString = linkingHelper.getCrossRefNodeAsString(lhsChildNode, true);
	    	//System.out.println("	2:" + lhsChildString + ", " + refChildString);
    		return lhsChildString.equals(refChildString);
    	} // recurse further down the trees (which are sequences in this case)
    	else if (lhsChild instanceof MemberAccess l && rhsChild instanceof MemberAccess r) {
    		return isPathsEqual(l, r);
    	}
    	// fall-through
    	//System.out.println("	3");
    	return false;
    }

    
    private EObject getSingleChild(EObject obj) {
    	var children = obj.eContents();
		if (children.size() != 1) { // should not happen unless the grammar is changed somehow
			throw new RuntimeException("Exactly one child expected, for object " + obj + ", but got " + children.size() + ". Did you change the grammar?");
		}
		return children.get(0);
    }
    
    
}
