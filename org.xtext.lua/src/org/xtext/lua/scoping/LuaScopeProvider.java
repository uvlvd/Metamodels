/*
 * generated by Xtext 2.34.0
 */
package org.xtext.lua.scoping;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameConverter;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.SimpleLocalScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;
import org.xtext.lua.linking.SyntheticExpNil;
import org.xtext.lua.lua.Block;
import org.xtext.lua.lua.Exp;
import org.xtext.lua.lua.ExpField;
import org.xtext.lua.lua.Feature;
import org.xtext.lua.lua.Field;
import org.xtext.lua.lua.FunctionDeclaration;
import org.xtext.lua.lua.Goto;
import org.xtext.lua.lua.IndexExpField;
import org.xtext.lua.lua.Label;
import org.xtext.lua.lua.NameField;
import org.xtext.lua.lua.Referenceable;
import org.xtext.lua.lua.Referencing;
import org.xtext.lua.lua.TableAccess;
import org.xtext.lua.lua.TableConstructor;
import org.xtext.lua.lua.Var;
import org.xtext.lua.utils.LinkingAndScopingUtils;

import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class LuaScopeProvider extends SimpleLocalScopeProvider {
	private static final Logger LOGGER = Logger.getLogger(LuaScopeProvider.class);
	
	@Inject
	private IQualifiedNameProvider qualifiedNameProvider;
	
  	@Inject
    private IQualifiedNameConverter nameConverter;
    
	/**
	 * NOTE: Always create IEObjectDescriptions using the qualifiedNameConverter when creating
	 * Scopes, see {@link #createDescriptionsForCandidates(Collection)}.
	 */
    @Override
    public IScope getScope(final EObject context, final EReference reference) {
        if (context == null) {
            // nothing to do without context
            return IScope.NULLSCOPE;
        }
        
        var scope = getScopeForAssignableToValue(context);
        
        /*
        System.out.println("foo");
        if (context instanceof Var var && var.getName().equals("require")) {
        	System.out.println("bar");
        	var globalScope = super.getGlobalScope(context.eResource(), reference, LuaGlobalScopeProvider.returnedExpAtIndexFilter(0));
        	System.out.println("   globalScope: " + globalScope);
        }*/
        
        if (scope != null) {
        	return scope;
        }
        
        scope = getScopeByTraversingBlocks(context);
        
        if (scope != null) {
        	return scope;
        }
        

        
		// search global scope if no candidates were found in local scope
    	//TODO: implement global scope
        System.out.println("Searchign global scope for " + context);
		return super.getGlobalScope(context.eResource(), reference);
		//return IScope.NULLSCOPE;
    }
    

    /**
     * Assignables and Fields reference their assigned value, this returns the respective scope.</br>
     * E.g.: a = {b = 1} returns 1 for context object b, and the right-hand side TableConstructor for context object a.
     * @param context the context object.
     * @return the scope, or null if the context object is not an assignable or Field.
     */
    private IScope getScopeForAssignableToValue(EObject context) {
        // fields (in TableConstructors) also reference their assigned value
        if (context instanceof Field field) {
        	return getScopeForField(field);
        }
    	// assignables (variables that get assigned a value in an Assignment) reference their assigned value
        if (LinkingAndScopingUtils.isAssignable(context)) {
        	return getScopeForAssignable(context);
        }
        
        return null;
    }

    /**
     * Returns the Scope for assignables. Assignables are Referenceables on the lhs of an Assignment,
     * and the returned Scope contains a single candidate: the corresponding value expression on the rhs of the Assignment. </br>
     * If there is no corresponding value expression (e.g. a, b = 1), a new ExpNil is created and set as reference (in the e.g. b).
     * @param assignable
     * @return
     */
    private IScope getScopeForAssignable(EObject assignable) {
    	final var name = ((Referenceable) assignable).getName();
		if (name == null) { // name might be null, e.g. for TableAccess with unresolvable indexExpression
			// TODO: return placeholder object or implement trivial recovery
			// TODO: name should not be null anymore, since TableAccesses get a dummy name?
			return IScope.NULLSCOPE;
		}
		
    	final var fqn = nameConverter.toQualifiedName(name);
    	final var value = LinkingAndScopingUtils.findAssignedExp(assignable);
		if (value == null) {
			// create synthetic nil value if ExpList does not contains value for assignable
			var nilValue = new SyntheticExpNil();
			var nilValueDescription = EObjectDescription.create(fqn, nilValue);
			return new SimpleScope(Collections.singletonList(nilValueDescription));
		} else {
			// any assignable is also a Referenceable which has a name attribute and a
			// cross-reference with linkText == name

			// we create a description with the name of the assignable and the corresponding value expression on the rhs of the assignment
			// => the scope for the assignable contains only this description
			var assignedValueDescription = EObjectDescription.create(fqn, value);
			return new SimpleScope(Collections.singletonList(assignedValueDescription));
		}
    }
    
    
    //TODO: this does not seem like the right location for this method, since the field names are computed here
    //      but the tableAccess names are computed in LuaLinkingService...
    /**
     * Returns the Scope for Fields. Every field has a value, which is the candidate returned in the returned scope.
     * Since not all names for fields can be computed, some fields may get assigned a dummy name.
     */
    private IScope getScopeForField(Field field) {
    	Exp value = null;
    	if (field instanceof IndexExpField indexExpField) {
    		value = indexExpField.getValueExp();
    	} else if (field instanceof NameField nameField) {
    		value = nameField.getValueExp();
    	} else if (field instanceof ExpField expField) {
    		value = expField.getExp();
    	}
    	
    	if (value == null) {
    		throw new RuntimeException("Could not determine value expression for field " + field);
    	}
    	
    	var name = field.getName();
    	if (name.equals(LinkingAndScopingUtils.DERIVED_DUMMY_NAME)) {
    		name = LinkingAndScopingUtils.tryGetNameForField(field, LinkingAndScopingUtils.LINKING_DUMMY_NAME);
    	}
    	
    	var fqn = nameConverter.toQualifiedName(name);
    	var assignedValueDescription = EObjectDescription.create(fqn, value);
    	return new SimpleScope(Collections.singletonList(assignedValueDescription));
    }

    
    private IScope getScopeByTraversingBlocks(final EObject context) {
    	final var currentBlock = EcoreUtil2.getContainerOfType(context, Block.class);
    	return getScopeByTraversingBlocks(context, currentBlock, null);
    }
    
    private IScope getScopeByTraversingBlocks(final EObject context, final Block currentBlock, final Block previousBlock) {
    	// search for candidates in current block
    	var candidates = getCandidatesFromBlock(context, currentBlock, previousBlock);
    	if (!candidates.isEmpty()) {
    		return new SimpleScope(createDescriptionsForCandidates(candidates, context));
    	}
    	
    	// search for candidates in parent block if none were found in current block
    	final var parentBlock = EcoreUtil2.getContainerOfType(currentBlock.eContainer(), Block.class);
		if (parentBlock != null) {
			return getScopeByTraversingBlocks(context, parentBlock, currentBlock);
		}
		
		// no parent block found, try global scope
		return null;
    }
    
    private List<? extends Referenceable> getCandidatesFromBlock(final EObject context, final Block currentBlock, final Block previousBlock) {
    	List<? extends Referenceable> candidates = new ArrayList<>();
    	List<? extends Referenceable> temp = new ArrayList<>();
    	// Get candidate Labels for Goto: Label names need to be unique within one block)
    	if (context instanceof Goto) {
    		// TODO: do not search global scope for GOTO references
    		candidates = getReferenceablesForGoto(currentBlock, previousBlock);
    	}
    	 // handle other Referencing objects
        if (context instanceof Referencing referencing) {
        	final var contextFqn = qualifiedNameProvider.getFullyQualifiedName(context);

        	
        	//TODO: it seems that the lazy linking happens before the DerivedStateComputer
        	// 	installs the derived state, thus the name is null.
        	//  need to change that somewhere...?
        	if (contextFqn != null) {
        		// TODO: getReferenceables should be renamed
	        	var referenceables = getReferenceables(context, currentBlock);
	        	
	        	if (context instanceof Feature feature) {
	        		temp = getCandidatesForFeature(feature, referenceables);
	        	}
	        	
	        	candidates = findCandidatesInReferenceablesforFqn(contextFqn, referenceables);
	        	
	        	if (!candidates.equals(temp)) {
		            System.out.println("Candidates for context " + context + " with fqn " + contextFqn);
		            System.out.println("	previous candidates: " + candidates);
		            System.out.println("	temp candidates    : " + temp);
	        	}
        	}
        }

        return temp;
    }
    
    // For functions, this could be a problem here: https://stackoverflow.com/questions/12291203/lua-how-to-call-a-function-prior-to-it-being-defined
    //  (could also affect Assignments)
    private List<? extends Referenceable> getReferenceables(final EObject context, final Block contextBlock) {
    	// we use the parentStatement to decide where to stop searching for candidates (i.e. only consider statements before the context's statement)
		final var contextParentStatementOpt = LinkingAndScopingUtils.getParentStatement(context);
    	if (!contextParentStatementOpt.isPresent()) {
    		LOGGER.warn("Found no contextParentStatement for obj " + context);
    		return Collections.emptyList();
    	}
    	final var contextParentStatement = contextParentStatementOpt.get();
    	
    	var referenceables = LinkingAndScopingUtils.getReferenceablesForContextFromBlock(context, contextBlock, contextParentStatement);
    	// reverse result s.t. the last assignment before the currently considered context is the first element in the resulting candidate list
    	Collections.reverse(referenceables);
    	return referenceables;
    }
    
    
    private List<? extends Referenceable> getReferenceablesForGoto(final Block contextBlock, final Block previousBlock) {
    	var referenceables = EcoreUtil2.getAllContentsOfType(contextBlock, Label.class)
    			.stream()
    			// we ignore the previous block, since it has been searched before (see getScopeByTraversingBlocks)
    			.filter(block -> block != previousBlock)
    			.collect(Collectors.toCollection(() -> new ArrayList<>()));
    	Collections.reverse(referenceables);
    	return referenceables;
    }
    
	// function findCandidatesInPathForFqn(fqn) that searches for feature candidates by fqn:
	// 1. Add all candidates with contextFqn.equals(candidateFqn) to result
    // 2.1 find all candidates with contextFqn.startsWith(candidateFqn)
	// 2.2 filter by: candidate.pointsToTable() 
	// 3. forall candidates if pointsToTable: 
    //    3.1 newFqnHead = candidate.getRef().getFqn()  // quit here if cannot be resolved
	//    3.2 contextFqnTail = contextFqn.remove(candidateFqn)
	//    3.3 furtherCandidates = findCandidatesInPathByFqn(newFqnHead + contextFqnTail)
	// 	  3.4 add result as description with (candidate.getFqn() + contextFqnTail, furtherCandidate)
	// 4. return candidates
    /**
     * 
     * @param contextFqn
     * @param context
     * @param scopeRoot
     * @return
     */
    //private Collection<Referenceable> findCandidatesInPathForFqn(QualifiedName contextFqn, final EObject context, final EObject scopeRoot) {
    //	var assignables = getAssignablesFromFor(scopeRoot, context);
    private List<? extends Referenceable> findCandidatesInReferenceablesforFqn(final QualifiedName contextFqn, final Collection<? extends Referenceable> referenceables) {
    	var result = new ArrayList<Referenceable>();

    	for (final var referenceable : referenceables) {
    		final var referenceableFqn = qualifiedNameProvider.getFullyQualifiedName(referenceable);
    		if (contextFqn.equals(referenceableFqn)) { // add all assignables with equal fqn
    			result.add(referenceable);
    		} else if (contextFqn.startsWith(referenceableFqn)) {
    			
    			
    			// TODO: check this out
    			if (!(referenceable instanceof Referencing)) {
    				// TODO: this will be logged e.g. when a function return value is accessed, e.g. see scopingFunctionDeclarationTest a.x.memberFunc()["member"]
    				LOGGER.warn("Skipped resolution of sub-part of feature path for non-referencing \n		" 
    							+ referenceable + " with fqn " 
    						    + referenceableFqn + 
    						    " for contextFqn " + contextFqn);
    				continue;
    			}
    			/*
    			if (LinkingAndScopingUtils.isFunctionCallFeature(referenceable)) {
    				System.out.println("--> Partly fitting refble is functionCallFeature: " + referenceable);
    			}*/
    			
    			// Handle assignables and their assigned values
    			if (!LinkingAndScopingUtils.isAssignable(referenceable)) {
    				continue;
    			}
    			// search candidates in partial feature paths, 
    			// e.g.: b.member = 1; a.x = b; c = a.x.member; here, the candidates for a.x.member need to consider b.member
        		final var assignedRef = (((Referencing) referenceable).getRef()); // rhs of assignable (might be a Referencing)
    			final var assignedValue = LinkingAndScopingUtils.tryGetAssignedValueFrom((Referencing) referenceable); // value of assignable (is not Referencing)
	
    			//System.out.println("--> assignedRef: " + assignedRef);
    			//System.out.println("--> assignedValue: " + assignedValue);
    			if (LinkingAndScopingUtils.isFunctionDeclaration(assignedRef) 
    					|| LinkingAndScopingUtils.isFunctionDeclaration(assignedValue)) {
    				var funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(assignedRef);
    				if (funcBody == null) {
    					funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(assignedValue);
    				}
    				if (funcBody == null) {
    					throw new RuntimeException("Could not find funcBody in EObjects althoug it should be a function declaration.");
    				}
    				/*
    				var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(funcBody.getFuncBlock());
    				if (returnStatOpt.isPresent()) {
    					var refbles = LinkingAndScopingUtils.getReferenceablesFromReturnStat(returnStatOpt.get(), qualifiedNameProvider);
    					System.out.println("--> refbles from function call: " + refbles);
    				}*/
    				
    				
    				
    			}
    			
        		if (assignedValue instanceof TableConstructor && assignedRef instanceof Referencing) {
        			var newFqnHead = qualifiedNameProvider.getFullyQualifiedName(assignedRef);
        			var newFqnTail = getFqnTail(contextFqn, referenceableFqn.getSegmentCount());
        			var newFqn = newFqnHead.append(newFqnTail);
        			
        			result.addAll(findCandidatesInReferenceablesforFqn(newFqn, referenceables)
        				.stream()
        				.toList()
        			);
        			
        		}
        		
    		}
    	}

    	return result;
    }
    
	// TODO: use this in findCandidatesInReferenceablesforFqn
	public List<? extends Referenceable> findCandidatesFromFeaturePath() {
		var result = new ArrayList<Referenceable>();
		// 1. contextFqn matches referenceableFqn
		
		// 2. contextFqn starts with referenceableFqn
		// 2.1 check Tables assigned to referenceables, build new fqn and take candidates
		//   like before
		// 2.2 search in function return values
		//   2.2.1 get function return values, set as new referenceables to be searched
		//   2.2.2 set newFqn to contextFqn - contextFqn.startThatEquals(referenceableFqn)
		//   2.2.3 recursive call with newFqn and newReferenceables
		return result;
	}
    
    
    
    
    
    
    public List<? extends Referenceable> searchForCandidatesWithFqnIn(final QualifiedName contextFqn, final Collection<? extends Referenceable> referenceables) {
    	var result = new ArrayList<Referenceable>();
    	// 1. if contextFqn.startsWith(referenceableFqn)
    	//    2. compute new referenceables: if referenceable points to other referenceable, add
    	//       add from func body if context is funcCall
    	//  recurse call self
    	return result;
    }
    
    private List<? extends Referenceable> getCandidatesForFeature(Feature feature, final Collection<? extends Referenceable> referenceables) {
    	var result = new ArrayList<Referenceable>();
    	//TODO: checkout LinkingAndScopingUtils.findFeaturePathRoot, which only returns roots for Referenceables
    	//    -> should probably be renamed
    	final var featurePathRoot = LinkingAndScopingUtils.getFeaturePathRoot(feature);
    	
    	if (feature instanceof TableAccess var && var.getName().equals("N__0.0"))
    	{
    		System.out.println("");
    	}
   
    	// get initial candidates for path root
    	var candidates = findCandidatesForFeature(featurePathRoot, null, referenceables);

    	Feature previousFeature = featurePathRoot;
    	while (LinkingAndScopingUtils.hasNextFeature(previousFeature)) {
    		if (previousFeature == feature) {
    			break;
    		}
    		
    		var currentFeature = LinkingAndScopingUtils.getNextFeature(previousFeature);
    		candidates = findCandidatesForFeature(currentFeature, previousFeature, candidates);
    		previousFeature = currentFeature;
    	}
    	// filter resulting candidates by viable candidates (last element of featurePath is also last element of candidate)
		candidates = findCandidatesForFeature(null, previousFeature, candidates);
    	
    	return candidates;
    }
    
    private FeaturePathCandidate buildFeaturePathCandidate(final Feature feature) {
    	final var fqn = qualifiedNameProvider.getFullyQualifiedName(feature);
    	return new FeaturePathCandidate(feature, fqn);
    }
    

    // this returns all candidates that can be reached by traversing a feature path, using the current and previous features
    // it is important to note, that this will return all candidates based on if the feature path matches UNTIL the current location
    // in the feature paths. That is, candidates that match and have a next feature component will be returned regardless of if a next feature exitst for the context feature
    private List<? extends Referenceable> findCandidatesForFeature(Feature current, Feature previous, final Collection<? extends Referenceable> candidates) {
    	var result = new ArrayList<Referenceable>();
    	
    	// idea: use hasNextFeature(current) to check if the feature path has ended, then filter candidates somehow
    	if (current == null) {
    		// there are no more features in the currently traversed feature path -> need to filter candidates
    		for (var candidate : candidates) {
    			if (LinkingAndScopingUtils.isFunctionCallFeature(previous)) {
    				// TODO: we might want to return the expressions returned by the function here
    			} else {
    				// when the last element of the feature path has been found (i.e. current == null), we need to check that the 
    				// candidates last segment name equals the referenced name, and that the candidate has no further features
    				final var lastFeatureName = qualifiedNameProvider.getFullyQualifiedName(previous).getLastSegment();
    				final var previousFeaturePathLocationIndex = getFeaturePathCountUntilLastFunctionCallFeature(previous) - 1;
        			final var candidateFqn = qualifiedNameProvider.getFullyQualifiedName(candidate);
        			final var candidateFqnTail = getFqnTailIncluding(candidateFqn, previousFeaturePathLocationIndex);
        			if (candidateFqnTail != null 
        					&& candidateFqnTail.getSegmentCount() == 1 
        					&& candidateFqnTail.getFirstSegment().equals(lastFeatureName)) {
        				result.add(candidate);
        			}
    			}
    		}
    		return result;
    	}
    	// handle previous is funcitonCall -> no fqn
    	if (LinkingAndScopingUtils.isFunctionCallFeature(previous)) {
    		// TODO: handle
    		if (LinkingAndScopingUtils.isFunctionCallFeature(current)) {
    			// resolve function call from candidates
    			for (var candidate : candidates) {
    				// viable candidates should be function declarations or reference to functions
        			result.addAll(findCandidatesForFunctionReference(candidate));

        		}
    		} else {
    			// treat current as new root
    		}
    		return result;
    	}
    	// fqns only contain parts for features with a name (i.e. Vars, MemberAccesses and TableAccesses)
    	// we use the length from the previous feature until the last occurrence of a FunctionCall-Feature since the referenceables
    	// returned by a functionCall have fqns that "stop" at the function block "border"
    	final var currentFeaturePathLocationIndex = getFeaturePathCountUntilLastFunctionCallFeature(current) - 1;
    	
    	//final var previousFqn = qualifiedNameProvider.getFullyQualifiedName(previous);
    	
    	// handle current is functionCall -> no fqn
    	if (LinkingAndScopingUtils.isFunctionCallFeature(current)) {
    		// We have two possibilities here: 1. previous is named feature or 2. previous itself was functionCallFeature
    		// For 1. the candidates were already filtered by name => get new candidates from candidate function return values
    		// For 2. the candidates already contain the return values from the previous functionCall => get new candidates from candidate function return values
    		for (var candidate : candidates) {
    			final var candidateFqn = qualifiedNameProvider.getFullyQualifiedName(candidate);
    			// filter candidates that end with feature with feature.name == previous.name and have correct fqn length
    			//var isFunctionReferenceCandidate = getFqnTail(candidateFqn, previousFqn.getSegmentCount()).isEmpty();
    			var isFunctionReferenceCandidate = candidateFqn.getSegmentCount() == currentFeaturePathLocationIndex;
    			if (isFunctionReferenceCandidate && candidate instanceof Referencing referencing) {
    				var referencedFunction = referencing.getRef();
    				result.addAll(findCandidatesForFunctionReference(referencedFunction));
    			}
    		}
    		return result;
    	}
    	
    	
    	final var currentFqn = qualifiedNameProvider.getFullyQualifiedName(current);
    	
    	
    	
    	if (current instanceof Referenceable referenceable) { // current has name attribute
    		//System.out.println("checking for - " + current + " with fqn " + currentFqn);
    		for (var candidate : candidates) {
    			var currentName = currentFqn.getLastSegment();
    			// remove the previously considered segments from the candidate fqn for comparison
    			final var candidateFqn = qualifiedNameProvider.getFullyQualifiedName(candidate);
    			/*
    			if (candidateFqn.getSegmentCount() < currentFeaturePathLocationIndex) {
    				// TODO: this is clunky
    				continue;
    			}*/
    			
    			final var candidateFqnTail = getFqnTailIncluding(candidateFqn, currentFeaturePathLocationIndex);
    			if (candidateFqnTail == null) {
    				// TODO: this is clunky, using the continue here
    				continue;
    			}
    			//System.out.println("  - candidateFqn: " + candidateFqn);
    			//System.out.println("  - candidateFqnTail: " + candidateFqnTail);
    			//System.out.println("  - currentFeaturePathLocationIndex: " + currentFeaturePathLocationIndex);
    			if (candidateFqnTail.startsWith(nameConverter.toQualifiedName(currentName))) {
    				result.add(candidate);
    				// find candidates from candidate feature
    				if (LinkingAndScopingUtils.isAssignable(candidate)) {
    					var assigned = ((Referencing) candidate).getRef();
    					if (assigned instanceof Referencing) {
    						// add all candidates that start with the assigned's name (since the assigned exp is referencing, i.e. some variable/featurePath)
    						var referenceablesFromCandidate = candidates.stream()
    									.filter(c -> qualifiedNameProvider.getFullyQualifiedName(c).startsWith(qualifiedNameProvider.getFullyQualifiedName(assigned)))
    									.toList();
        					result.addAll(referenceablesFromCandidate);
        					System.out.println("   - - - adding mult: " + referenceablesFromCandidate);
    					}		
    				} 
    				
    				
    				/*
    				else if (LinkingAndScopingUtils.isFunctionDeclaration(candidate)) {
    					System.out.println("fooooooUnctionDeclaration");
    					var funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(candidate);
    					if (funcBody != null) {
    						var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(funcBody.getFuncBlock());
    						if (returnStatOpt.isPresent()) {
    							var referenceablesFromCandidate = LinkingAndScopingUtils.getReferenceablesFromReturnStat(returnStatOpt.get(), qualifiedNameProvider);
    							result.addAll(candidates);
    						}
    						
    					}
    				}
    				
    				*/
    			}
    		}
    	}

    	
    	// Idea:
    	//   - since we have the current and the previous feature, we can use the currentFqn and previousFqn
    	//     to calculate which candidates are viable:
    	//     - when comparing fqns of candidates, we start at candidateFqn segment with index previousFqn.segmentCount
    	//         and check if that part of the candidateFqn startsWith(current.getName())
    	//     - if previous is Function/MemberFuncCall we start at fqn candidateFqn 0 (since the referenceables should only contain returned refebles from the previous function)
    	//     - etc. -> profit?
    	
    	
    	// TODO: work through all cases:
    	// if current is namedFeature -> 
    	//      if previous was function/memberFuncCall -> candidates should only contain returned values, search candidates for 
    	//         startsWith(current)
    	// 
    	/*
    	var featureFqn = qualifiedNameProvider.getFullyQualifiedName(current);
    	
    	for (final var candidate : candidates) {
    		var candidateFqn = qualifiedNameProvider.getFullyQualifiedName(candidate);
    		if (featureFqn.equals(candidateFqn)) {
    			// add all candidates with matching fqn
    			result.add(candidate);
    			// check if we need to add candidates from references, e.g. if the candidate is assigned to a FuncitonCall or another Variable
    			if (LinkingAndScopingUtils.isAssignable(candidate)) {
    				//var assignedExp = ((Referencing) candidate).getRef();
    				
    			}
    		}
    	}
    	*/
    	
    	return result;
    }
    
    private int getFeaturePathCountUntilLastFunctionCallFeature(Feature feature) {
    	if (feature == null || LinkingAndScopingUtils.isFunctionCallFeature(feature)) {
    		return 0;
    	}

    	int length = 1; // we start at the given feature, i.e. path has at least one element
    	// we use the fqn to ensure that the length returned here does not exceed the feature's fqn, e.g. when it stops at TableAccesses
    	var fqn = qualifiedNameProvider.getFullyQualifiedName((Referenceable) feature);
    	var parent = feature.eContainer();
    	while (parent instanceof Feature f && length < fqn.getSegmentCount()) {
    		// only count features with a name (i.e. Var, MemberAcces, TableAccess)
    		if (!LinkingAndScopingUtils.isFunctionCallFeature(f)) {
    			length++;
    		}
    		parent = parent.eContainer();
    	}
    	
    	return length;
    }
    
    private List<? extends Referenceable> findCandidatesForFunctionReference (Referenceable functionReference) {
    	var result = new ArrayList<Referenceable>();
    	if (functionReference instanceof Referencing referencing) {
    		// TODO: might need to get referenced function if the given functionReference is a Referencing object (e.g. func = func1, b = func())
    		//    could use LinkingAndScopingUtils.tryGetAssignedValueFrom(referencing) or smth similar
    	}
    	if (LinkingAndScopingUtils.isFunctionDeclaration(functionReference)) {
			System.out.println("fooooooUnctionDeclaration");
			var funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(functionReference);
			if (funcBody != null) {
				var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(funcBody.getFuncBlock());
				if (returnStatOpt.isPresent()) {
					var referenceablesFromCandidate = LinkingAndScopingUtils.getReferenceablesFromReturnStat(returnStatOpt.get(), qualifiedNameProvider);
					// only add candidates from first returned expression
					if (!referenceablesFromCandidate.isEmpty()) {
						result.addAll(referenceablesFromCandidate.get(0));
					}
					
				}
			}
		}
    	return result;
    }
    
    private List<? extends Referenceable> findCandidatesForFunctionCalls(final Collection<? extends Referenceable> candidates) {
    	var result = new ArrayList<Referenceable>();
    	
    	for (final var candidate : candidates) {
        	if (LinkingAndScopingUtils.isFunctionDeclaration(candidate)) {
    			System.out.println("fooooooUnctionDeclaration");
    			var funcBody = LinkingAndScopingUtils.getFuncBodyFromFuncObject(candidate);
    			if (funcBody != null) {
    				var returnStatOpt = LinkingAndScopingUtils.findReturnStatInBlock(funcBody.getFuncBlock());
    				if (returnStatOpt.isPresent()) {
    					var referenceablesFromCandidate = LinkingAndScopingUtils.getReferenceablesFromReturnStat(returnStatOpt.get(), qualifiedNameProvider);
    					// only add candidates from first returned expression
    					if (!referenceablesFromCandidate.isEmpty()) {
    						result.addAll(referenceablesFromCandidate.get(0));
    					}
    					
    				}
    			}
    		}
    	}
    	
    	return result;
    }
    

    
    private List<? extends Referenceable> temp(Feature current, Feature previous, final Collection<? extends Referenceable> candidates) {
    	var result = new ArrayList<Referenceable>();
    	
    	return result;
    }
    

    
    private QualifiedName getFqnTail(QualifiedName forFqn, int startIndex) {
    	var resultSegments = new ArrayList<String>();
    	for (var i = 0; i < forFqn.getSegmentCount(); i++) {
    		if (i >= startIndex) {
    			resultSegments.add(forFqn.getSegment(i));
    		}
    	}
    	
    	if (resultSegments.isEmpty()) {
    		throw new RuntimeException("Cannot get tail for " + forFqn + " with startIndex " + startIndex + "!");
    	}
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (int i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    private QualifiedName getFqnTailIncluding(QualifiedName forFqn, int startIndex) {
    	var resultSegments = new ArrayList<String>();
    	for (var i = 0; i < forFqn.getSegmentCount(); i++) {
    		if (i >= startIndex) {
    			resultSegments.add(forFqn.getSegment(i));
    		}
    	}
    	
    	if (resultSegments.isEmpty()) {
    		return null;
    		//throw new RuntimeException("Cannot get tail for " + forFqn + " with startIndex " + startIndex + "!");
    	}
    	
    	var result = nameConverter.toQualifiedName(resultSegments.get(0));
    	for (int i = 1; i < resultSegments.size(); i++) {
    		result = result.append(resultSegments.get(i));
    	}

    	return result;
    }
    
    
    /**
     * We always need to create descriptions (instead of returning Scopes.scopeFor(candidates)), since the 
     * candidates name might contain ".", which would fail to match the QualifiedName generated from the cross-reference
     * in the DefaultLinkingService.</br>
     * This is because the qualifiedNameConverter uses "." to separate Strings, i.e.
     * the generated cross-reference QualifiedName for "hello.world" would be "hello" "world", which would not match
     * the candidate's name "hello.world".</br></br>
     * 
     * An alternative would be to extend the IQualifiedNameConverter.DefaultImpl and change/remove the delimiter.</br></br>
	 *
     * @param candidates The candidates.
     * @return A list of EObjectDescriptions of the candidates, created by applying the qualifiedNameConverter to the candidate's name attribute.
     */
    private Collection<IEObjectDescription> createDescriptionsForCandidates(Collection<? extends Referenceable> candidates, EObject context) {
    	return candidates.stream()
    				.map(c ->{
    					var name = c.getName();
    					if (c instanceof FunctionDeclaration fd) {
    						name = getLastSegmentFromFunctionDeclarationName(fd);
    					}
    					return EObjectDescription.create(nameConverter.toQualifiedName(name), c);
    				})
    				.toList();
    }

    private String getLastSegmentFromFunctionDeclarationName(FunctionDeclaration fd) {
    	var qn = nameConverter.toQualifiedName(fd.getName());
    	return qn.getLastSegment();
    } 
    
}
